//@version=6
indicator('ICT + FVG + RSI V1.2.2', shorttitle="ICT + FVG Pro 1.2.2", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500, max_bars_back=5000)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ METADADOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Nome:        ICT + FVG + RSI
// VersÃ£o:      1.2.2
// Atualizado:  2026-02-19
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“œ CHANGELOG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V1.2.2 (2026-02-19)
//    - Bug Fix: FVG expiraÃ§Ã£o migrada de tempo-relÃ³gio para bar_index
//      (corrige inflaÃ§Ã£o de idade em mercados com gap noturno, ex: aÃ§Ãµes)
//    - Bug Fix: Garbage collection de candles HTF ao desativar o grupo
//    - Performance: Reorder/Update restritos a barstate.isnew/islast
//    - Performance: FindImbalance com dirty flag â€” evita recriaÃ§Ã£o total

// V1.2.1 (2026-02-14)
//    - Anti-Repaint: Monitor usa barstate.ishistory em vez de barstate.islast
//    - Bug Fix: RSI fallback nz() removido â€” evita mistura de dados entre TFs
//    - Limpeza: helper.name (cÃ³digo morto) removido de todos os mÃ©todos
//    - ManutenÃ§Ã£o: Constantes SEC_1H, SEC_4H, SEC_1D extraÃ­das
//
// V1.2.0 (2026-02-12)
//    - Bug Fix: request.security desenrolado do loop (5 chamadas explÃ­citas)
//    - Bug Fix: DayofWeek corrigido (usa constantes dayofweek.monday etc.)
//    - Bug Fix: str.tonumber substituÃ­do por timeframe.in_seconds no Monitor
//    - Anti-Repaint: Monitor agora exige barstate.isconfirmed para criar candle
//    - Anti-Repaint: MitigaÃ§Ã£o/expiraÃ§Ã£o FVG apenas em barstate.isconfirmed
//    - Performance: var adicionado a Settings, Helper e color_transparent
//    - Robustez: ValidTimeframe usa modulo (n2 % n1 == 0)
//    - Robustez: Debug table protegido contra NaN (nz/na checks)
//
// V1.1.8 (2025-12-20)
//    - Robustness: Zero-division protection in isExpired method.
//    - Robustness: Bounds checking and fallback for invalid RSI data.
//    - Robustness: RSI table automatically recreates when changing columns.
//    - Extensibility: ATR Period is now configurable via user input.
//    - Extensibility: Configurable Timezone (5 options).
//    - Extensibility: RSI table timeframes are now dynamic.
//
// V1.1.6 (2025-12-19)
//    - Optimization: Simplified conditional calculation of RSI levels.
//    - Refactoring: RSI Cache only calculates levels when visual lines are active.
//    - UX: Updated Debug table version to reflect current release.
//
// V1.1.5 (2025-12-18)
//    - New: Checkboxes to toggle RSI columns in the table.
//    - Improved UX: Independent control for RSI display and levels.
//
// V1.1.4 (2025-12-18)
//    - Optimization: RSI_ALPHA pre-calculated as a 'var' constant.
//    - Fix: f_fvg_detect() now normalizes gap size by ATR when ATR Auto is active.
//    - Prevents false positives on volatile or low-priced assets.
//    - Logical Consistency: Threshold and gap size now use the same unit of measure.
//
// V1.1.3 (2025-12-17)
//    - Tooltips added to all 60+ indicator inputs.
//    - Improved inline documentation for better TradingView UX.
//    - Clear descriptions for every parameter.
//
// V1.1.2 (2025-12-16)
//    - Critical Fix: box.set_top/bottom now uses math.max/min.
//    - Bugfix: Corrected rendering for bullish HTF candles.
//    - Improvement: Candle body now always uses correct coordinates.
//
// V1.1.1 (2025-12-16)
//    - Historical timer changed from '---' to '--:--' (time format).
//    - Optimized FindImbalance: Now processes only on new HTF candles.
//    - Performance: Removed unnecessary box.copy() + box.delete() calls.
//    - Tracking: Implemented idx-based tracking to prevent imbalance duplication.
//    - Visual Sync: FVG boxes now follow HTF candle movement.
//    - Fix: Condition FVG >= 3 (detects with exactly 3 candles).
//
// V1.1 (2025-12-15)
//    - Removed scale=scale.none for better candle visualization.
//    - Timer changed from 'n/a' to '---' on historical data.
//    - Added comprehensive documentation.
//
// V1.0 (2025-12-14)
//    - Initial Release: ICT HTF Candles + FVG + RSI + MTF merge.
//    - RSI Cache system implemented.
//    - Added Debug mode for FVG.
//    - Configured alerts.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”¢ CONSTANTES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const int MAX_TABLE_ROWS = 7
const int MAX_ITER_PER_BAR = 20
const int MAX_REMOVALS = 10
const int MS_PER_SECOND = 1000
const int SEC_1H  = 3600
const int SEC_4H  = 14400
const int SEC_1D  = 86400

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¦ TYPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
type Candle
    float o
    float c
    float h
    float l
    int o_time
    int o_idx
    int c_idx
    int h_idx
    int l_idx
    string dow
    box body
    line wick_up
    line wick_down
    label dow_label

type Trace
    line o
    line c
    line h
    line l
    label o_l
    label c_l
    label h_l
    label l_l

type Imbalance
    box b
    int idx
    int arr_i1
    int arr_i2

type CandleSettings
    bool show
    string htf
    int max_display

type Settings
    int max_sets
    color bull_body
    color bull_border
    color bull_wick
    color bear_body
    color bear_border
    color bear_wick
    int offset
    int buffer
    int htf_buffer
    int width
    bool daily_name
    bool trace_show
    color trace_o_color
    string trace_o_style
    int trace_o_size
    color trace_c_color
    string trace_c_style
    int trace_c_size
    color trace_h_color
    string trace_h_style
    int trace_h_size
    color trace_l_color
    string trace_l_style
    int trace_l_size
    string trace_anchor
    bool label_show
    color label_color
    string label_size
    string label_position
    string label_alignment
    bool fvg_show
    color fvg_color
    bool vi_show
    color vi_color
    bool htf_label_show
    color htf_label_color
    string htf_label_size
    bool htf_timer_show
    color htf_timer_color
    string htf_timer_size
    color dow_color
    string dow_size

type CandleSet
    array<Candle> candles
    array<Imbalance> imbalances
    CandleSettings settings
    label tfNameTop
    label tfNameBottom
    label tfTimerTop
    label tfTimerBottom


type FVG
    float top
    float bottom
    bool isBull
    int birthTime
    int birthBarIndex
    box boxObj
    line mitigatedLine
    bool isActive

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// [FIX v1.2.0] var adicionado â€” Settings e Helper alocados uma Ãºnica vez
var Settings settings = Settings.new()
var CandleSettings SettingsHTF1 = CandleSettings.new()
var CandleSettings SettingsHTF2 = CandleSettings.new()
var CandleSettings SettingsHTF3 = CandleSettings.new()
var CandleSettings SettingsHTF4 = CandleSettings.new()
var CandleSettings SettingsHTF5 = CandleSettings.new()
var CandleSettings SettingsHTF6 = CandleSettings.new()

string group_htf = "ğŸ“Š HTF Candles  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_style = "ğŸ¨ Styling  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_label = "ğŸ·ï¸ Labels  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_imbalance = "âš–ï¸ MTF Imbalances  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_trace = "ğŸ“ Trace Lines  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_ema = "ğŸ“ˆ EMA  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_rsi = "ğŸ“‰ RSI  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_table = "ğŸ“‹ Tabela RSI  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_fvg = "ğŸ¯ FVG GrÃ¡fico  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

SettingsHTF1.show := input.bool(true, 'HTF 1', inline='htf1', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 1')
htf_1 = input.timeframe('5', '', inline='htf1', group=group_htf)
SettingsHTF1.htf := htf_1
SettingsHTF1.max_display := input.int(10, '', inline='htf1', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF2.show := input.bool(true, 'HTF 2', inline='htf2', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 2')
htf_2 = input.timeframe('15', '', inline='htf2', group=group_htf)
SettingsHTF2.htf := htf_2
SettingsHTF2.max_display := input.int(8, '', inline='htf2', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF3.show := input.bool(true, 'HTF 3', inline='htf3', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 3')
htf_3 = input.timeframe('60', '', inline='htf3', group=group_htf)
SettingsHTF3.htf := htf_3
SettingsHTF3.max_display := input.int(6, '', inline='htf3', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF4.show := input.bool(true, 'HTF 4', inline='htf4', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 4')
htf_4 = input.timeframe('240', '', inline='htf4', group=group_htf)
SettingsHTF4.htf := htf_4
SettingsHTF4.max_display := input.int(5, '', inline='htf4', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF5.show := input.bool(true, 'HTF 5', inline='htf5', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 5 (Daily)')
htf_5 = input.timeframe('1D', '', inline='htf5', group=group_htf)
SettingsHTF5.htf := htf_5
SettingsHTF5.max_display := input.int(5, '', inline='htf5', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF6.show := input.bool(true, 'HTF 6', inline='htf6', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 6 (Weekly)')
htf_6 = input.timeframe('1W', '', inline='htf6', group=group_htf)
SettingsHTF6.htf := htf_6
SettingsHTF6.max_display := input.int(3, '', inline='htf6', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

settings.max_sets := input.int(3, 'Limite HTFs', minval=1, maxval=6, group=group_htf, tooltip='NÃºmero mÃ¡ximo de grupos HTF a exibir simultaneamente (1-6)')
i_timezone = input.string('America/Sao_Paulo', 'Fuso HorÃ¡rio', options=['America/Sao_Paulo', 'America/New_York', 'Europe/London', 'Asia/Tokyo', 'UTC'], group=group_htf, tooltip='Fuso horÃ¡rio para cÃ¡lculo de datas e horÃ¡rios dos candles HTF')
i_auto_daily = input.bool(true, 'Daily Auto (>=1H)', group=group_htf, tooltip='Mostra MTF Daily apenas quando grÃ¡fico estÃ¡ em 1H ou acima')
i_auto_weekly = input.bool(true, 'Weekly Auto (>=4H)', group=group_htf, tooltip='Mostra MTF Weekly apenas quando grÃ¡fico estÃ¡ em 4H ou acima')

bool showDailyAuto = i_auto_daily and timeframe.in_seconds() >= SEC_1H
if i_auto_daily
    SettingsHTF5.show := showDailyAuto

bool showWeeklyAuto = i_auto_weekly and timeframe.in_seconds() >= SEC_4H
if i_auto_weekly
    SettingsHTF6.show := showWeeklyAuto

settings.bull_body := input.color(color.new(#089981, 70),'Body Bull/Bear', inline='body', group=group_style, tooltip='Cor do corpo dos candles de alta (esquerda) e baixa (direita)')
settings.bear_body := input.color(color.new(#f23645, 70), '', inline='body', group=group_style)
settings.bull_border := input.color(color.new(#000000,70), 'Border', inline='borders', group=group_style, tooltip='Cor da borda dos candles de alta e baixa')
settings.bear_border := input.color(color.new(#000000,70), '', inline='borders', group=group_style)
settings.bull_wick := input.color(color.new(color.black, 70), 'Wick', inline='wick', group=group_style, tooltip='Cor dos pavios dos candles de alta e baixa')
settings.bear_wick := input.color(color.new(color.black, 70), '', inline='wick', group=group_style)
settings.offset := input.int(30, 'Offset', minval=1, group=group_style, tooltip='DistÃ¢ncia horizontal entre o Ãºltimo candle do grÃ¡fico e os HTF candles')
settings.buffer := input.int(1, 'Buffer', minval=1, maxval=4, group=group_style, tooltip='EspaÃ§amento entre candles individuais dentro de um grupo HTF')
settings.htf_buffer := input.int(5, 'HTF Buffer', minval=1, maxval=10, group=group_style, tooltip='EspaÃ§amento entre grupos de diferentes timeframes')
settings.width := input.int(1, 'Width', minval=1, maxval=4, group=group_style, tooltip='Largura visual dos candles HTF (multiplicado por 2)') * 2

settings.htf_label_show := input.bool(true, 'HTF Label', inline='HTFlabel', group=group_label, tooltip='Exibe o nome do timeframe acima/abaixo dos candles')
settings.htf_label_color := input.color(color.new(#000000, 0), '', inline='HTFlabel', group=group_label)
settings.htf_label_size := input.string(size.normal, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='HTFlabel', group=group_label)
settings.label_position := input.string("Top", 'Position', options=['Both', 'Top', 'Bottom'], group=group_label, tooltip='PosiÃ§Ã£o do label: Topo, Base ou Ambos')
settings.label_alignment := input.string("Follow Candles", "Alignment", options=['Align', 'Follow Candles'], group=group_label, tooltip='Align: labels alinhados | Follow: labels seguem posiÃ§Ã£o dos candles')
settings.htf_timer_show := input.bool(true, 'Timer', inline='timer', group=group_label, tooltip='Exibe contagem regressiva atÃ© o fechamento do candle HTF')
settings.htf_timer_color := input.color(color.new(color.black, 10), '', inline='timer', group=group_label)
settings.htf_timer_size := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='timer', group=group_label)
settings.daily_name := input.bool(true, 'DOW Label', inline='dow', group=group_label, tooltip='Exibe nome do dia da semana (Seg, Ter...) para candles diÃ¡rios')
settings.dow_color := input.color(color.black, '', inline='dow', group=group_label)
settings.dow_size := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='dow', group=group_label)

settings.fvg_show := input.bool(true, 'FVG MTF', inline='fvg', group=group_imbalance, tooltip='Detecta e exibe Fair Value Gaps nos candles HTF')
settings.fvg_color := input.color(color.rgb(120, 123, 134, 85),'', inline='fvg', group=group_imbalance)
settings.vi_show := input.bool(false, 'VI MTF', inline='vi', group=group_imbalance, tooltip='Detecta e exibe Volume Imbalances nos candles HTF')
settings.vi_color := input.color(color.new(color.red, 50), '', inline='vi', group=group_imbalance)

settings.trace_show := input.bool(false, 'Trace Lines', group=group_trace, tooltip='Desenha linhas conectando OHLC do candle atual atÃ© os HTF candles')
settings.trace_o_color := input.color(color.new(color.gray, 50), 'Open', inline='1', group=group_trace, tooltip='Linha do preÃ§o de abertura: cor, estilo e espessura')
settings.trace_o_style := input.string('Â·Â·Â·Â·', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='1', group=group_trace)
settings.trace_o_size := input.int(1, '', options=[1, 2, 3, 4], inline='1', group=group_trace)
settings.trace_c_color := input.color(color.new(color.gray, 50), 'Close', inline='2', group=group_trace, tooltip='Linha do preÃ§o de fechamento: cor, estilo e espessura')
settings.trace_c_style := input.string('Â·Â·Â·Â·', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='2', group=group_trace)
settings.trace_c_size := input.int(1, '', options=[1, 2, 3, 4], inline='2', group=group_trace)
settings.trace_h_color := input.color(color.new(color.gray, 50), 'High', inline='3', group=group_trace, tooltip='Linha da mÃ¡xima: cor, estilo e espessura')
settings.trace_h_style := input.string('â¯â¯â¯', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='3', group=group_trace)
settings.trace_h_size := input.int(1, '', options=[1, 2, 3, 4], inline='3', group=group_trace)
settings.trace_l_color := input.color(color.new(color.gray, 50), 'Low', inline='4', group=group_trace, tooltip='Linha da mÃ­nima: cor, estilo e espessura')
settings.trace_l_style := input.string('â¯â¯â¯', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='4', group=group_trace)
settings.trace_l_size := input.int(1, '', options=[1, 2, 3, 4], inline='4', group=group_trace)
settings.trace_anchor := input.string('First Timeframe', 'Anchor', options=['First Timeframe', 'Last Timeframe'], group=group_trace, tooltip='Define qual grupo HTF recebe as trace lines')
settings.label_show := input.bool(false, 'Price Labels', inline='label', group=group_trace, tooltip='Exibe labels com os preÃ§os OHLC nas extremidades das linhas')
settings.label_color := input.color(color.new(color.black, 10), '', inline='label', group=group_trace)
settings.label_size := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='label', group=group_trace)

i_showEMA = input.bool(false, 'âš¡ Ativar EMA', group=group_ema, tooltip='Ativa a MÃ©dia MÃ³vel Exponencial no grÃ¡fico')
i_emaLength = input.int(26, 'PerÃ­odo', minval=1, maxval=500, group=group_ema, tooltip='NÃºmero de barras para cÃ¡lculo da EMA (padrÃ£o: 26)')
i_emaColor = input.color(#4a4a4acc, 'Cor', group=group_ema, tooltip='Cor da linha EMA')
i_emaWidth = input.int(1, 'Espessura', minval=1, maxval=5, group=group_ema, tooltip='Espessura da linha EMA')
i_emaSource = input.source(close, 'Fonte', group=group_ema, tooltip='Fonte de dados para cÃ¡lculo (close, open, high, low, hl2, etc.)')

i_rsi_length = input.int(14, 'PerÃ­odo RSI', minval=2, maxval=200, group=group_rsi, tooltip='PerÃ­odo para cÃ¡lculo do RSI (padrÃ£o: 14)')
i_show_rsi_25 = input.bool(false, 'Exibir NÃ­vel 25', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 25')
i_show_rsi_30 = input.bool(false, 'Exibir NÃ­vel 30', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 30 (sobrevendido)')
i_show_rsi_50 = input.bool(false, 'Exibir NÃ­vel 50', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 50 (neutro)')
i_show_rsi_70 = input.bool(false, 'Exibir NÃ­vel 70', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 70 (sobrecomprado)')
i_show_rsi_75 = input.bool(false, 'Exibir NÃ­vel 75', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 75')
i_show_rsi_custom = input.bool(false, 'â­ Exibir RSI Customizado', group=group_rsi, tooltip='Plota linha horizontal para um nÃ­vel RSI personalizado')
i_rsi_custom_level = input.float(40, 'NÃ­vel RSI Customizado', minval=1, maxval=99, step=1, group=group_rsi, tooltip='Define o nÃ­vel RSI desejado para a linha customizada (1-99)')
i_rsi_custom_color = input.color(color.new(#ff9800, 0), 'Cor RSI Customizado', group=group_rsi, tooltip='Cor da linha RSI customizada')
i_rsi_max_deviation = input.float(0.30, 'Desvio MÃ¡ximo (%)', minval=0.10, maxval=1.00, step=0.05, group=group_rsi, tooltip='Limite mÃ¡ximo de variaÃ§Ã£o de preÃ§o para cÃ¡lculos RSI (evita valores extremos)')

i_table_show = input.bool(true, 'Exibir Tabela', group=group_table, tooltip='Ativa a tabela multi-timeframe com valores RSI e preÃ§os-alvo')
i_rsi_tf1 = input.timeframe('5', 'TF 1', inline='rsi_tf1', group=group_table, tooltip='Timeframe 1 da tabela RSI')
i_rsi_tf1_name = input.string('5m', '', inline='rsi_tf1', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf2 = input.timeframe('15', 'TF 2', inline='rsi_tf2', group=group_table, tooltip='Timeframe 2 da tabela RSI')
i_rsi_tf2_name = input.string('15m', '', inline='rsi_tf2', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf3 = input.timeframe('60', 'TF 3', inline='rsi_tf3', group=group_table, tooltip='Timeframe 3 da tabela RSI')
i_rsi_tf3_name = input.string('1h', '', inline='rsi_tf3', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf4 = input.timeframe('240', 'TF 4', inline='rsi_tf4', group=group_table, tooltip='Timeframe 4 da tabela RSI')
i_rsi_tf4_name = input.string('4h', '', inline='rsi_tf4', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf5 = input.timeframe('D', 'TF 5', inline='rsi_tf5', group=group_table, tooltip='Timeframe 5 da tabela RSI')
i_rsi_tf5_name = input.string('1D', '', inline='rsi_tf5', group=group_table, tooltip='Nome exibido na tabela')
i_table_show_col1 = input.bool(false, 'Exibir Coluna 1', inline='col1', group=group_table, tooltip='Ativa/desativa a coluna de preÃ§o para o nÃ­vel RSI 1')
i_table_col1_level = input.float(30, '', minval=1, maxval=99, step=1, inline='col1', group=group_table, tooltip='NÃ­vel RSI para calcular preÃ§o')
i_table_show_col2 = input.bool(false, 'Exibir Coluna 2', inline='col2', group=group_table, tooltip='Ativa/desativa a coluna de preÃ§o para o nÃ­vel RSI 2')
i_table_col2_level = input.float(70, '', minval=1, maxval=99, step=1, inline='col2', group=group_table, tooltip='NÃ­vel RSI para calcular preÃ§o')
i_table_position = input.string('top_right', 'PosiÃ§Ã£o', options=['top_right', 'top_left', 'bottom_right', 'bottom_left'], group=group_table, tooltip='PosiÃ§Ã£o da tabela RSI no grÃ¡fico')

i_fvg_enabled = input.bool(true, 'âš¡ Ativar FVG', group=group_fvg, tooltip='Ativa detecÃ§Ã£o e exibiÃ§Ã£o de Fair Value Gaps no grÃ¡fico principal')
i_fvg_auto_threshold = input.bool(false, 'Threshold ATR Auto', group=group_fvg, tooltip='Quando ativo, usa ATR para calcular automaticamente o limiar mÃ­nimo de FVG')
i_fvg_threshold = input.float(0.3, 'Limiar (%)', minval=0.01, maxval=10, step=0.05, group=group_fvg, tooltip='Tamanho mÃ­nimo do gap em % para ser considerado FVG')
i_fvg_adaptive_tf = input.bool(true, 'Adaptativo TF', group=group_fvg, tooltip='Multiplica o limiar baseado no timeframe')
i_fvg_max_multiplier = input.float(5.0, 'Mult. MÃ¡ximo', minval=1.0, maxval=20.0, step=0.5, group=group_fvg, tooltip='Limite mÃ¡ximo do multiplicador adaptativo por timeframe')
i_fvg_timeframe = input.timeframe('', 'Timeframe', group=group_fvg, tooltip='Timeframe para detecÃ§Ã£o de FVG (vazio = TF atual)')
i_fvg_extend_bars = input.int(15, 'ExtensÃ£o', minval=5, maxval=200, group=group_fvg, tooltip='Quantas barras a caixa FVG se estende para a direita')
i_fvg_max_count = input.int(8, 'MÃ¡ximo FVGs', minval=1, maxval=50, group=group_fvg, tooltip='NÃºmero mÃ¡ximo de FVGs ativos simultaneamente')
i_fvg_max_age = input.int(300, 'Idade MÃ¡x', minval=50, maxval=1000, group=group_fvg, tooltip='Remove FVGs nÃ£o mitigados apÃ³s esta quantidade de barras')
i_fvg_bull_color = input.color(color.new(#089981, 85), 'Cor Alta', group=group_fvg, tooltip='Cor das caixas FVG bullish')
i_fvg_bear_color = input.color(color.new(#f23645, 85), 'Cor Baixa', group=group_fvg, tooltip='Cor das caixas FVG bearish')
i_fvg_mitigation_type = input.string('50% (Meio)', 'MitigaÃ§Ã£o', options=['50% (Meio)', '100% (Completo)', '25% (Conservador)'], group=group_fvg, tooltip='Define quando um FVG Ã© considerado mitigado')
i_fvg_debug = input.bool(false, 'Debug Mode', group=group_fvg, tooltip='Exibe tabela de debug com informaÃ§Ãµes tÃ©cnicas sobre os FVGs')
i_atr_period = input.int(14, 'ATR PerÃ­odo', minval=5, maxval=50, group=group_fvg, tooltip='PerÃ­odo do ATR usado no threshold automÃ¡tico de FVG')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ VARIÃVEIS GLOBAIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var array<Candle> candles_1 = array.new<Candle>(0)
var array<Candle> candles_2 = array.new<Candle>(0)
var array<Candle> candles_3 = array.new<Candle>(0)
var array<Candle> candles_4 = array.new<Candle>(0)
var array<Candle> candles_5 = array.new<Candle>(0)
var array<Candle> candles_6 = array.new<Candle>(0)

var array<Imbalance> imbalances_1 = array.new<Imbalance>()
var array<Imbalance> imbalances_2 = array.new<Imbalance>()
var array<Imbalance> imbalances_3 = array.new<Imbalance>()
var array<Imbalance> imbalances_4 = array.new<Imbalance>()
var array<Imbalance> imbalances_5 = array.new<Imbalance>()
var array<Imbalance> imbalances_6 = array.new<Imbalance>()

var int g_last_imb_idx_1 = -1
var int g_last_imb_idx_2 = -1
var int g_last_imb_idx_3 = -1
var int g_last_imb_idx_4 = -1
var int g_last_imb_idx_5 = -1
var int g_last_imb_idx_6 = -1

var bool prev_show_htf1 = true
var bool prev_show_htf2 = true
var bool prev_show_htf3 = true
var bool prev_show_htf4 = true
var bool prev_show_htf5 = true
var bool prev_show_htf6 = true

var CandleSet htf1 = CandleSet.new()
htf1.settings := SettingsHTF1
htf1.candles := candles_1
htf1.imbalances := imbalances_1

var CandleSet htf2 = CandleSet.new()
htf2.settings := SettingsHTF2
htf2.candles := candles_2
htf2.imbalances := imbalances_2

var CandleSet htf3 = CandleSet.new()
htf3.settings := SettingsHTF3
htf3.candles := candles_3
htf3.imbalances := imbalances_3

var CandleSet htf4 = CandleSet.new()
htf4.settings := SettingsHTF4
htf4.candles := candles_4
htf4.imbalances := imbalances_4

var CandleSet htf5 = CandleSet.new()
htf5.settings := SettingsHTF5
htf5.candles := candles_5
htf5.imbalances := imbalances_5

var CandleSet htf6 = CandleSet.new()
htf6.settings := SettingsHTF6
htf6.candles := candles_6
htf6.imbalances := imbalances_6

// [FIX v1.2.1] Helper removido â€” mÃ©todos convertidos em funÃ§Ãµes puras
var Trace trace = Trace.new()
// [FIX v1.2.0] var adicionado
var color color_transparent = #ffffff00

// RSI
float RSI_ALPHA = 1.0 / i_rsi_length
var array<string> g_rsi_tfs = array.from(i_rsi_tf1, i_rsi_tf2, i_rsi_tf3, i_rsi_tf4, i_rsi_tf5)
var array<string> g_rsi_tfs_display = array.from(i_rsi_tf1_name, i_rsi_tf2_name, i_rsi_tf3_name, i_rsi_tf4_name, i_rsi_tf5_name)
var float[] g_rsi_values = array.new_float(5, na)
var float[] g_rsi_close = array.new_float(5, na)
var float[] g_rsi_auc = array.new_float(5, na)
var float[] g_rsi_adc = array.new_float(5, na)
var float g_cached_rsi25 = na
var float g_cached_rsi30 = na
var float g_cached_rsi50 = na
var float g_cached_rsi70 = na
var float g_cached_rsi75 = na
var float g_cached_rsi_custom = na
var int g_last_calc_bar = -1
var table g_rsi_table = na
var int g_prev_col_config = 0

// FVG GrÃ¡fico
var array<FVG> g_active_fvgs = array.new<FVG>()
var int g_prev_fvg_time = 0
var int g_last_fvg_time = 0
var array<int> g_fvg_to_remove = array.new<int>()
var int g_tf_seconds = 0
var table g_debug_table = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡Ã•ES AUXILIARES - ICT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_line_style(string style) =>
    switch style
        '----' => line.style_dashed
        'Â·Â·Â·Â·' => line.style_dotted
        => line.style_solid

// [FIX v1.2.0] DayofWeek corrigido â€” usa constantes Pine + default robusto
f_day_of_week(int index) =>
    if na(index)
        ''
    else
        switch index
            dayofweek.monday    => 'Seg'
            dayofweek.tuesday   => 'Ter'
            dayofweek.wednesday => 'Qua'
            dayofweek.thursday  => 'Qui'
            dayofweek.friday    => 'Sex'
            dayofweek.saturday  => 'SÃ¡b'
            dayofweek.sunday    => 'Dom'
            => ''

// [FIX v1.2.0] ValidTimeframe usa modulo para precisÃ£o
f_valid_timeframe(string HTF) =>
    if timeframe.in_seconds(HTF) >= timeframe.in_seconds('D') and timeframe.in_seconds(HTF) > timeframe.in_seconds()
        true
    else
        n1 = timeframe.in_seconds()
        n2 = timeframe.in_seconds(HTF)
        n1 < n2 and n2 % n1 == 0

f_remaining_time(string HTF, int openTime) =>
    if barstate.islast
        // [FIX] CÃ¡lculo matemÃ¡tico (evita request.security em bloco condicional)
        int duration = timeframe.in_seconds(HTF) * 1000
        int closeTime = openTime + duration
        timeRemaining = math.max(0, (closeTime - timenow) / 1000)
        days = math.floor(timeRemaining / SEC_1D)
        hours = math.floor((timeRemaining - days * SEC_1D) / SEC_1H)
        minutes = math.floor((timeRemaining - days * SEC_1D - hours * SEC_1H) / 60)
        seconds = math.floor(timeRemaining - days * SEC_1D - hours * SEC_1H - minutes * 60)
        r = str.tostring(seconds, '00')
        if minutes > 0 or hours > 0 or days > 0
            r := str.tostring(minutes, '00') + ':' + r
        if hours > 0 or days > 0
            r := str.tostring(hours, '00') + ':' + r
        if days > 0
            r := str.tostring(days) + 'D ' + r
        r
    else
        '--:--'

f_htf_name(string HTF) =>
    seconds = timeframe.in_seconds(HTF)
    if seconds < 60
        str.tostring(seconds) + 's'
    else if seconds / 60 < 60
        str.tostring(seconds / 60) + 'm'
    else if seconds / 60 / 60 < 24
        str.tostring(seconds / 60 / 60) + 'H'
    else
        HTF

f_htf_enabled() =>
    int enabled = 0
    enabled += htf1.settings.show ? 1 : 0
    enabled += htf2.settings.show ? 1 : 0
    enabled += htf3.settings.show ? 1 : 0
    enabled += htf4.settings.show ? 1 : 0
    enabled += htf5.settings.show ? 1 : 0
    enabled += htf6.settings.show ? 1 : 0
    math.min(enabled, settings.max_sets)

f_candle_set_high(array<Candle> candles, float h) =>
    float _h = h
    if candles.size() > 0
        for i = 0 to candles.size() - 1
            if candles.get(i).h > _h
                _h := candles.get(i).h
    _h

f_candle_set_low(array<Candle> candles, float l) =>
    float _l = l
    if candles.size() > 0
        for i = 0 to candles.size() - 1
            if candles.get(i).l < _l
                _l := candles.get(i).l
    _l

f_candles_high() =>
    h = 0.0
    int cnt = 0
    int last = f_htf_enabled()
    if htf1.settings.show and f_valid_timeframe(htf1.settings.htf)
        h := f_candle_set_high(htf1.candles, h), cnt += 1
    if htf2.settings.show and f_valid_timeframe(htf2.settings.htf) and cnt < last
        h := f_candle_set_high(htf2.candles, h), cnt += 1
    if htf3.settings.show and f_valid_timeframe(htf3.settings.htf) and cnt < last
        h := f_candle_set_high(htf3.candles, h), cnt += 1
    if htf4.settings.show and f_valid_timeframe(htf4.settings.htf) and cnt < last
        h := f_candle_set_high(htf4.candles, h), cnt += 1
    if htf5.settings.show and f_valid_timeframe(htf5.settings.htf) and cnt < last
        h := f_candle_set_high(htf5.candles, h), cnt += 1
    if htf6.settings.show and f_valid_timeframe(htf6.settings.htf) and cnt < last
        h := f_candle_set_high(htf6.candles, h)
    h

f_candles_low(float h) =>
    l = h
    int cnt = 0
    int last = f_htf_enabled()
    if htf1.settings.show and f_valid_timeframe(htf1.settings.htf)
        l := f_candle_set_low(htf1.candles, l), cnt += 1
    if htf2.settings.show and f_valid_timeframe(htf2.settings.htf) and cnt < last
        l := f_candle_set_low(htf2.candles, l), cnt += 1
    if htf3.settings.show and f_valid_timeframe(htf3.settings.htf) and cnt < last
        l := f_candle_set_low(htf3.candles, l), cnt += 1
    if htf4.settings.show and f_valid_timeframe(htf4.settings.htf) and cnt < last
        l := f_candle_set_low(htf4.candles, l), cnt += 1
    if htf5.settings.show and f_valid_timeframe(htf5.settings.htf) and cnt < last
        l := f_candle_set_low(htf5.candles, l), cnt += 1
    if htf6.settings.show and f_valid_timeframe(htf6.settings.htf) and cnt < last
        l := f_candle_set_low(htf6.candles, l)
    l

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡Ã•ES RSI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_rsi_ema_length() => math.max(1, 2 * i_rsi_length - 1)

f_rsi_color(float r) =>
    switch
        na(r)   => [color.new(#44475a, 0), color.new(#6272a4, 0)]  // Sem dado â†’ Dracula comment
        r < 20  => [color.new(#14755f, 0), color.new(#f8f8f2, 0)]  // Muito sobrevendido â†’ ciano escuro
        r < 30  => [color.new(#3de1c7, 0), color.new(#282a36, 0)]  // Sobrevendido â†’ ciano mÃ©dio
        r < 44  => [color.new(#b5f9ef, 0), color.new(#282a36, 0)]  // Leve alta â†’ ciano pastel
        r <= 55 => [color.new(#282a36, 0), color.new(#f8f8f2, 0)]  // Neutro â†’ fundo Dracula
        r < 70  => [color.new(#ffb8d0, 0), color.new(#282a36, 0)]  // Leve baixa â†’ rosa pastel
        r < 80  => [color.new(#ff4d8d, 0), color.new(#282a36, 0)]  // Sobrecomprado â†’ rosa mÃ©dio
        =>         [color.new(#8b1048, 0), color.new(#f8f8f2, 0)]  // Muito sobrecomprado â†’ rosa escuro


f_rsi_is_valid(float c, float au, float ad) =>
    not na(c) and not na(au) and not na(ad) and c > 0 and au >= 0 and ad >= 0

f_rsi_calc_price(float target_rsi, float close_val, float auc_val, float adc_val) =>
    if not f_rsi_is_valid(close_val, auc_val, adc_val) or target_rsi <= 0 or target_rsi >= 100
        na
    else
        alpha = RSI_ALPHA
        denominator = 100.0 - target_rsi
        if denominator == 0
            na
        else
            target_rs = target_rsi / denominator
            float calc_price = na
            if target_rsi < 50
                new_avg_up = (1 - alpha) * auc_val
                new_avg_down = target_rs == 0 ? na : new_avg_up / target_rs
                d_loss = na(new_avg_down) ? na : (new_avg_down - (1 - alpha) * adc_val) / alpha
                calc_price := na(d_loss) ? na : close_val - d_loss
            else
                new_avg_down = (1 - alpha) * adc_val
                new_avg_up = target_rs * new_avg_down
                d_gain = (new_avg_up - (1 - alpha) * auc_val) / alpha
                calc_price := close_val + d_gain
            if na(calc_price)
                na
            else
                min_p = close_val * (1 - i_rsi_max_deviation)
                max_p = close_val * (1 + i_rsi_max_deviation)
                math.max(min_p, math.min(max_p, calc_price))

f_rsi_pack() =>
    emaLen = f_rsi_ema_length()
    [close, ta.rsi(close, i_rsi_length), ta.ema(math.max(close - close[1], 0), emaLen), ta.ema(math.max(close[1] - close, 0), emaLen)]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡Ã•ES FVG GRÃFICO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_fvg_get_tf_multiplier(int tf_sec) =>
    float result = switch
        tf_sec <= 60 => 0.5
        tf_sec <= 300 => 0.5 + (tf_sec - 60) * (0.75 - 0.5) / (300 - 60)
        tf_sec <= 900 => 0.75 + (tf_sec - 300) * (1.0 - 0.75) / (900 - 300)
        tf_sec <= SEC_1H => 1.0 + (tf_sec - 900) * (1.5 - 1.0) / (SEC_1H - 900)
        tf_sec <= SEC_4H => 1.5 + (tf_sec - SEC_1H) * (2.2 - 1.5) / (SEC_4H - SEC_1H)
        tf_sec <= SEC_1D => 2.2 + (tf_sec - SEC_4H) * (4.0 - 2.2) / (SEC_1D - SEC_4H)
        => 8.0
    math.min(i_fvg_max_multiplier, result)

f_fvg_get_mitigation_level(float top, float bottom, string mitType, bool isBull) =>
    if mitType == '100% (Completo)'
        isBull ? bottom : top
    else if mitType == '25% (Conservador)'
        isBull ? top - (top - bottom) * 0.25 : bottom + (top - bottom) * 0.25
    else
        (top + bottom) / 2.0

method draw(FVG this) =>
    if not na(this) and this.isActive
        x1 = this.birthTime
        x2 = this.birthTime + (g_tf_seconds * MS_PER_SECOND * i_fvg_extend_bars)
        boxColor = this.isBull ? i_fvg_bull_color : i_fvg_bear_color
        this.boxObj := box.new(left=x1, top=this.top, right=x2, bottom=this.bottom, xloc=xloc.bar_time, border_color=na, bgcolor=boxColor)

method remove(FVG this, bool wasMitigated, float mitigationPrice) =>
    if not na(this)
        if not na(this.boxObj)
            this.boxObj.delete()
            this.boxObj := na
        this.isActive := false

method checkMitigation(FVG this) =>
    bool isMitigated = false
    float mitigationLevel = f_fvg_get_mitigation_level(this.top, this.bottom, i_fvg_mitigation_type, this.isBull)
    if time > this.birthTime
        isMitigated := this.isBull ? (low <= mitigationLevel) : (high >= mitigationLevel)
    [isMitigated, mitigationLevel]

method isExpired(FVG this) =>
    if this.birthBarIndex < 0
        false
    else
        barsAge = bar_index - this.birthBarIndex
        barsAge > i_fvg_max_age

f_fvg_detect() =>
    float atr_value = i_fvg_auto_threshold or i_fvg_debug ? ta.atr(i_atr_period) : na
    float threshold = na
    float bullGapSize = na
    float bearGapSize = na
    if i_fvg_auto_threshold
        float atr_safe = math.max(atr_value, syminfo.mintick)
        threshold := 1.0
        if i_fvg_adaptive_tf
            threshold := threshold * f_fvg_get_tf_multiplier(g_tf_seconds)
        bullGapSize := (low - high[2]) / atr_safe
        bearGapSize := (low[2] - high) / atr_safe
    else
        threshold := i_fvg_threshold / 100.0
        if i_fvg_adaptive_tf
            threshold := threshold * f_fvg_get_tf_multiplier(g_tf_seconds)
        bullGapSize := (low - high[2]) / math.max(high[2], syminfo.mintick)
        bearGapSize := (low[2] - high) / math.max(low[2], syminfo.mintick)
    isBullFvg = low > high[2] and bullGapSize > threshold
    isBearFvg = high < low[2] and bearGapSize > threshold
    bool hasEnoughBars = bar_index >= 2 and not na(time[2])
    FVG newFvg = isBullFvg and hasEnoughBars ? FVG.new(low, high[2], true, time[2], bar_index - 2, na, na, true) : isBearFvg and hasEnoughBars ? FVG.new(low[2], high, false, time[2], bar_index - 2, na, na, true) : FVG.new(na, na, false, 0, -1, na, na, false)
    [isBullFvg, isBearFvg, newFvg, threshold, atr_value]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§± MÃ‰TODOS CANDLESET
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
method UpdateTime(CandleSet candleSet, int offset) =>
    if candleSet.candles.size() > 0
        Candle candle = candleSet.candles.get(0)
        candle.c := close
        candle.c_idx := bar_index
        if high > candle.h
            candle.h := high
            candle.h_idx := bar_index
        if low < candle.l
            candle.l := low
            candle.l_idx := bar_index
    candleSet

method Reorder(CandleSet candleSet, int offset) =>
    size = candleSet.candles.size()
    if size > 0 and (barstate.isnew or barstate.islast or barstate.isrealtime)
        for i = size - 1 to 0
            Candle candle = candleSet.candles.get(i)
            t_buffer = offset + (settings.width + settings.buffer) * (size - i - 1)
            box.set_left(candle.body, bar_index + t_buffer)
            box.set_right(candle.body, bar_index + settings.width + t_buffer)
            line.set_x1(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x1(candle.wick_down, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_down, bar_index + settings.width / 2 + t_buffer)
            if settings.daily_name
                if not na(candle.dow_label)
                    candle.dow_label.set_y(candle.h)
                    candle.dow_label.set_x(bar_index + settings.width / 2 + t_buffer)
                else
                    candle.dow_label := label.new(bar_index + settings.width / 2 + t_buffer, candle.h, candle.dow, color=color_transparent, textcolor=settings.dow_color, style=label.style_label_down, size=settings.dow_size)
    top = 0.0
    bottom = 0.0
    if settings.label_alignment == 'Align'
        top := f_candles_high()
        bottom := f_candles_low(top)
    if settings.label_alignment == 'Follow Candles'
        top := f_candle_set_high(candleSet.candles, 0)
        bottom := f_candle_set_low(candleSet.candles, top)
    left = bar_index + offset + (settings.width + settings.buffer) * (size - 1) / 2
    if settings.htf_label_show
        string lblt = f_htf_name(candleSet.settings.htf)
        string lbll = lblt
        if settings.htf_timer_show
            lblt := lblt + '\n'
            lbll := '\n' + lbll
        if settings.daily_name
            lblt := lblt + '\n'
        int currentOpenTime = 0
        if candleSet.candles.size() > 0
            currentOpenTime := candleSet.candles.get(0).o_time
        string tmr = '(' + f_remaining_time(candleSet.settings.htf, currentOpenTime) + ')' + (settings.daily_name ? '\n' : '')
        if settings.label_position == 'Both' or settings.label_position == 'Top'
            if not na(candleSet.tfNameTop)
                candleSet.tfNameTop.set_xy(left, top)
            else
                candleSet.tfNameTop := label.new(left, top, lblt, color=color_transparent, textcolor=settings.htf_label_color, style=label.style_label_down, size=settings.htf_label_size)
            if settings.htf_timer_show
                if not na(candleSet.tfTimerTop)
                    candleSet.tfTimerTop.set_xy(left, top)
                    candleSet.tfTimerTop.set_text(tmr)
                else
                    candleSet.tfTimerTop := label.new(left, top, tmr, color=color_transparent, textcolor=settings.htf_timer_color, style=label.style_label_down, size=settings.htf_timer_size)
        if settings.label_position == 'Both' or settings.label_position == 'Bottom'
            if not na(candleSet.tfNameBottom)
                candleSet.tfNameBottom.set_xy(left, bottom)
            else
                candleSet.tfNameBottom := label.new(left, bottom, lbll, color=color_transparent, textcolor=settings.htf_label_color, style=label.style_label_up, size=settings.htf_label_size)
            if settings.htf_timer_show
                if not na(candleSet.tfTimerBottom)
                    candleSet.tfTimerBottom.set_xy(left, bottom)
                    candleSet.tfTimerBottom.set_text(tmr)
                else
                    candleSet.tfTimerBottom := label.new(left, bottom, tmr, color=color_transparent, textcolor=settings.htf_timer_color, style=label.style_label_up, size=settings.htf_timer_size)
    if candleSet.imbalances.size() > 0
        for i = 0 to candleSet.imbalances.size() - 1
            Imbalance imb = candleSet.imbalances.get(i)
            t_buf2 = offset + (settings.width + settings.buffer) * (size - imb.arr_i2 - 1)
            t_buf1 = offset + (settings.width + settings.buffer) * (size - imb.arr_i1 - 1)
            box.set_left(imb.b, bar_index + t_buf2)
            box.set_right(imb.b, bar_index + t_buf1 + settings.width)
    candleSet

method Update(CandleSet candleSet, int offset, bool showTrace) =>
    candleSet.Reorder(offset)
    if candleSet.candles.size() > 0
        Candle candle = candleSet.candles.get(0)
        bull = candle.c > candle.o
        box.set_top(candle.body, math.max(candle.o, candle.c))
        box.set_bottom(candle.body, math.min(candle.o, candle.c))
        box.set_bgcolor(candle.body, bull ? settings.bull_body : settings.bear_body)
        box.set_border_color(candle.body, bull ? settings.bull_border : settings.bear_border)
        line.set_y1(candle.wick_up, candle.h)
        line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
        line.set_color(candle.wick_up, bull ? settings.bull_wick : settings.bear_wick)
        line.set_y1(candle.wick_down, math.min(candle.o, candle.c))
        line.set_y2(candle.wick_down, candle.l)
        line.set_color(candle.wick_down, bull ? settings.bull_wick : settings.bear_wick)
        if showTrace and settings.trace_show
            t_buffer = offset + (settings.width + settings.buffer) * (candleSet.candles.size() - 1)
            if not na(trace.o)
                line.set_xy1(trace.o, bar_index, candle.o), line.set_xy2(trace.o, bar_index + t_buffer, candle.o)
            else
                trace.o := line.new(bar_index, candle.o, bar_index + t_buffer, candle.o, color=settings.trace_o_color, style=f_line_style(settings.trace_o_style), width=settings.trace_o_size)
            if not na(trace.c)
                line.set_xy1(trace.c, bar_index, candle.c), line.set_xy2(trace.c, bar_index + t_buffer, candle.c)
            else
                trace.c := line.new(bar_index, candle.c, bar_index + t_buffer, candle.c, color=settings.trace_c_color, style=f_line_style(settings.trace_c_style), width=settings.trace_c_size)
            if not na(trace.h)
                line.set_xy1(trace.h, bar_index, candle.h), line.set_xy2(trace.h, bar_index + t_buffer, candle.h)
            else
                trace.h := line.new(bar_index, candle.h, bar_index + t_buffer, candle.h, color=settings.trace_h_color, style=f_line_style(settings.trace_h_style), width=settings.trace_h_size)
            if not na(trace.l)
                line.set_xy1(trace.l, bar_index, candle.l), line.set_xy2(trace.l, bar_index + t_buffer, candle.l)
            else
                trace.l := line.new(bar_index, candle.l, bar_index + t_buffer, candle.l, color=settings.trace_l_color, style=f_line_style(settings.trace_l_style), width=settings.trace_l_size)
            if settings.label_show
                if not na(trace.o_l)
                    label.set_xy(trace.o_l, bar_index + t_buffer + settings.width, candle.o)
                else
                    trace.o_l := label.new(bar_index + t_buffer + settings.width, candle.o, str.tostring(candle.o, format.mintick), color=color_transparent, textcolor=settings.label_color, style=label.style_label_left, size=settings.label_size)
                if not na(trace.c_l)
                    label.set_xy(trace.c_l, bar_index + t_buffer + settings.width, candle.c)
                else
                    trace.c_l := label.new(bar_index + t_buffer + settings.width, candle.c, str.tostring(candle.c, format.mintick), color=color_transparent, textcolor=settings.label_color, style=label.style_label_left, size=settings.label_size)
                if not na(trace.h_l)
                    label.set_xy(trace.h_l, bar_index + t_buffer + settings.width, candle.h)
                else
                    trace.h_l := label.new(bar_index + t_buffer + settings.width, candle.h, str.tostring(candle.h, format.mintick), color=color_transparent, textcolor=settings.label_color, style=label.style_label_left, size=settings.label_size)
                if not na(trace.l_l)
                    label.set_xy(trace.l_l, bar_index + t_buffer + settings.width, candle.l)
                else
                    trace.l_l := label.new(bar_index + t_buffer + settings.width, candle.l, str.tostring(candle.l, format.mintick), color=color_transparent, textcolor=settings.label_color, style=label.style_label_left, size=settings.label_size)
    candleSet

method FindImbalance(CandleSet candleSet) =>
    int candleCount = candleSet.candles.size()
    if candleCount >= 3 and (barstate.isrealtime or barstate.islast)
        Candle lastCandle = candleSet.candles.get(candleCount - 1)
        int currentCandleIdx = lastCandle.o_idx
        int lastProcessedIdx = candleSet.imbalances.size() > 0 ? candleSet.imbalances.get(candleSet.imbalances.size() - 1).idx : -1
        // [FIX v1.2.2] Dirty flag: sÃ³ reprocessa se hÃ¡ candle novo
        bool isNewCandle = currentCandleIdx != lastProcessedIdx
        if isNewCandle and (barstate.isconfirmed or barstate.ishistory)
            if candleSet.imbalances.size() > 0
                for i = candleSet.imbalances.size() - 1 to 0
                    Imbalance del = candleSet.imbalances.get(i)
                    box.delete(del.b)
                    candleSet.imbalances.pop()
            if candleCount >= 3 and settings.fvg_show
                for i = 0 to candleCount - 3 by 1
                    candle1 = candleSet.candles.get(i)
                    candle2 = candleSet.candles.get(i + 2)
                    if candle1.l > candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_left(candle2.body), candle2.h, box.get_right(candle1.body), candle1.l, bgcolor=settings.fvg_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 2
                        candleSet.imbalances.push(imb)
                    if candle1.h < candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_right(candle1.body), candle1.h, box.get_left(candle2.body), candle2.l, bgcolor=settings.fvg_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 2
                        candleSet.imbalances.push(imb)
            if candleCount > 2 and settings.vi_show
                for i = 0 to candleCount - 2 by 1
                    candle1 = candleSet.candles.get(i)
                    candle2 = candleSet.candles.get(i + 1)
                    if candle1.l < candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_left(candle2.body), math.min(candle1.o, candle1.c), box.get_right(candle1.body), math.max(candle2.o, candle2.c), bgcolor=settings.vi_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 1
                        candleSet.imbalances.push(imb)
                    if candle1.h > candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_right(candle1.body), math.min(candle2.o, candle2.c), box.get_left(candle2.body), math.max(candle1.o, candle1.c), bgcolor=settings.vi_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 1
                        candleSet.imbalances.push(imb)
    candleSet

// [FIX v1.2.0] Monitor usa timeframe.in_seconds
method Monitor(CandleSet candleSet) =>
    // [FIX v1.2.0] Usa forma nativa simples para alinhar com o mercado
    HTFBarTime = time(candleSet.settings.htf)
    isNewHTFCandle = ta.change(HTFBarTime) > 0
    // Anti-repaint: cria em barra confirmada, com fallback para carga histÃ³rica
    if isNewHTFCandle and (barstate.isconfirmed or barstate.ishistory)
        Candle candle = Candle.new()
        candle.o := open, candle.c := close, candle.h := high, candle.l := low
        candle.o_time := time, candle.o_idx := bar_index, candle.c_idx := bar_index
        candle.h_idx := bar_index, candle.l_idx := bar_index
        // [FIX v1.2.0] Usa timeframe.in_seconds() em vez de str.tonumber()
        int htfSec = timeframe.in_seconds(candleSet.settings.htf)
        candle.dow := switch
            candleSet.settings.htf == '1W' => 'Sem ' + str.tostring(weekofyear(time, i_timezone))
            candleSet.settings.htf == '1D' => f_day_of_week(dayofweek(time_tradingday))
            htfSec < SEC_1H => str.format_time(candle.o_time, 'm', i_timezone)
            htfSec >= SEC_1H and htfSec < SEC_1D => str.format_time(candle.o_time, 'H', i_timezone)
            => ''
        bull = candle.c > candle.o
        candle.body := box.new(bar_index, math.max(candle.o, candle.c), bar_index + 2, math.min(candle.o, candle.c), bull ? settings.bull_border : settings.bear_border, 1, bgcolor=bull ? settings.bull_body : settings.bear_body)
        candle.wick_up := line.new(bar_index + 1, candle.h, bar_index, math.max(candle.o, candle.c), color=bull ? settings.bull_wick : settings.bear_wick)
        candle.wick_down := line.new(bar_index + 1, math.min(candle.o, candle.c), bar_index, candle.l, color=bull ? settings.bull_wick : settings.bear_wick)
        candleSet.candles.unshift(candle)
        if candleSet.candles.size() > candleSet.settings.max_display
            Candle delCandle = array.pop(candleSet.candles)
            box.delete(delCandle.body)
            line.delete(delCandle.wick_up)
            line.delete(delCandle.wick_down)
            if not na(delCandle.dow_label)
                delCandle.dow_label.delete()
    candleSet

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š CÃLCULOS & REQUEST.SECURITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ema_value = ta.ema(i_emaSource, i_emaLength)
rsiEmaLength = f_rsi_ema_length()
rsi_current = ta.rsi(close, i_rsi_length)
auc_current = ta.ema(math.max(close - close[1], 0), rsiEmaLength)
adc_current = ta.ema(math.max(close[1] - close, 0), rsiEmaLength)

// [FIX v1.2.0] request.security desenrolado â€” Pine v6 proÃ­be dentro de loops
[c1, r1, au1, ad1] = request.security(syminfo.tickerid, i_rsi_tf1, f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
[c2, r2, au2, ad2] = request.security(syminfo.tickerid, i_rsi_tf2, f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
[c3, r3, au3, ad3] = request.security(syminfo.tickerid, i_rsi_tf3, f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
[c4, r4, au4, ad4] = request.security(syminfo.tickerid, i_rsi_tf4, f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
[c5, r5, au5, ad5] = request.security(syminfo.tickerid, i_rsi_tf5, f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)

g_rsi_close.set(0, c1), g_rsi_values.set(0, r1), g_rsi_auc.set(0, au1), g_rsi_adc.set(0, ad1)
g_rsi_close.set(1, c2), g_rsi_values.set(1, r2), g_rsi_auc.set(1, au2), g_rsi_adc.set(1, ad2)
g_rsi_close.set(2, c3), g_rsi_values.set(2, r3), g_rsi_auc.set(2, au3), g_rsi_adc.set(2, ad3)
g_rsi_close.set(3, c4), g_rsi_values.set(3, r4), g_rsi_auc.set(3, au4), g_rsi_adc.set(3, ad4)
g_rsi_close.set(4, c5), g_rsi_values.set(4, r5), g_rsi_auc.set(4, au5), g_rsi_adc.set(4, ad5)

tfFinal = i_fvg_timeframe == '' ? timeframe.period : i_fvg_timeframe
g_tf_seconds := timeframe.in_seconds(tfFinal)
[isBull, isBear, detectedFvg, thresholdUsed, atrValue] = request.security(syminfo.tickerid, tfFinal, f_fvg_detect(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš¡ LÃ“GICA PRINCIPAL - FVG GRÃFICO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if barstate.isconfirmed
    g_prev_fvg_time := g_last_fvg_time

if i_fvg_enabled and barstate.isconfirmed and (isBull or isBear) and detectedFvg.birthTime > g_last_fvg_time
    if g_active_fvgs.size() < i_fvg_max_count and detectedFvg.isActive
        g_last_fvg_time := detectedFvg.birthTime
        detectedFvg.draw()
        g_active_fvgs.unshift(detectedFvg)

// [FIX v1.2.0] Anti-repaint: mitigaÃ§Ã£o/expiraÃ§Ã£o APENAS em barstate.isconfirmed
if i_fvg_enabled and barstate.isconfirmed and g_active_fvgs.size() > 0
    if g_fvg_to_remove.size() > 0
        g_fvg_to_remove.clear()
    int arraySize = g_active_fvgs.size()
    int maxIter = math.min(arraySize, MAX_ITER_PER_BAR)
    for i = 0 to maxIter - 1
        if g_fvg_to_remove.size() >= MAX_REMOVALS
            break
        fvg = g_active_fvgs.get(i)
        if fvg.isActive
            [wasMitigated, mitigationPrice] = fvg.checkMitigation()
            wasExpired = fvg.isExpired()
            if wasMitigated or wasExpired
                fvg.remove(wasMitigated, mitigationPrice)
                g_fvg_to_remove.push(i)
    if g_fvg_to_remove.size() > 0
        g_fvg_to_remove.sort(order.descending)
        for i = 0 to g_fvg_to_remove.size() - 1
            g_active_fvgs.remove(g_fvg_to_remove.get(i))

// [FIX v1.2.0] Garbage collection: limpa FVGs quando feature desligada
if not i_fvg_enabled and g_active_fvgs.size() > 0
    for i = 0 to g_active_fvgs.size() - 1
        fvg = g_active_fvgs.get(i)
        if fvg.isActive
            fvg.remove(false, na)
    g_active_fvgs.clear()
    g_last_fvg_time := 0
    g_prev_fvg_time := 0

// === BLOCO DE CACHE RSI ===
bool use_rsi_25 = i_show_rsi_25
bool use_rsi_30 = i_show_rsi_30
bool use_rsi_50 = i_show_rsi_50
bool use_rsi_70 = i_show_rsi_70
bool use_rsi_75 = i_show_rsi_75
bool use_rsi_custom = i_show_rsi_custom

bool should_calculate = barstate.isnew or (barstate.islast and g_last_calc_bar != bar_index)
if should_calculate
    g_cached_rsi25 := use_rsi_25 ? f_rsi_calc_price(25.0, close, auc_current, adc_current) : na
    g_cached_rsi30 := use_rsi_30 ? f_rsi_calc_price(30.0, close, auc_current, adc_current) : na
    g_cached_rsi50 := use_rsi_50 ? f_rsi_calc_price(50.0, close, auc_current, adc_current) : na
    g_cached_rsi70 := use_rsi_70 ? f_rsi_calc_price(70.0, close, auc_current, adc_current) : na
    g_cached_rsi75 := use_rsi_75 ? f_rsi_calc_price(75.0, close, auc_current, adc_current) : na
    g_cached_rsi_custom := i_show_rsi_custom ? f_rsi_calc_price(i_rsi_custom_level, close, auc_current, adc_current) : na
    g_last_calc_bar := bar_index

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ RENDERIZAÃ‡ÃƒO VISUAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// EMA
plot(i_showEMA ? ema_value : na, title='EMA', color=i_emaColor, linewidth=i_emaWidth)

// RSI Lines
plot(i_show_rsi_25 ? g_cached_rsi25 : na, 'RSI 25', color.new(#00bcd4, 0), 1, plot.style_line)
plot(i_show_rsi_30 ? g_cached_rsi30 : na, 'RSI 30', color.new(color.red, 0), 1, plot.style_line)
plot(i_show_rsi_50 ? g_cached_rsi50 : na, 'RSI 50', color.new(color.gray, 0), 1, plot.style_line)
plot(i_show_rsi_70 ? g_cached_rsi70 : na, 'RSI 70', color.new(color.green, 0), 1, plot.style_line)
plot(i_show_rsi_75 ? g_cached_rsi75 : na, 'RSI 75', color.new(#ff5722, 0), 1, plot.style_line)
plot(i_show_rsi_custom ? g_cached_rsi_custom : na, 'RSI Custom', i_rsi_custom_color, 2, plot.style_line)

// === TABELA RSI MTF ===
bool show_col1 = i_table_show_col1
bool show_col2 = i_table_show_col2
int total_cols = 2
int col_p1 = na
if show_col1
    col_p1 := total_cols
    total_cols += 1
int col_p2 = na
if show_col2
    col_p2 := total_cols
    total_cols += 1

pos_rsi = switch i_table_position
    'top_right' => position.top_right
    'top_left' => position.top_left
    'bottom_right' => position.bottom_right
    => position.bottom_left


if i_table_show and barstate.islast
    int current_col_config = (show_col1 ? 1 : 0) + (show_col2 ? 2 : 0)
    if current_col_config != g_prev_col_config and not na(g_rsi_table)
        table.delete(g_rsi_table)
        g_rsi_table := na
    g_prev_col_config := current_col_config
    if na(g_rsi_table)
        g_rsi_table := table.new(pos_rsi, total_cols, MAX_TABLE_ROWS, bgcolor=color.new(#282a36, 0), border_width=0, frame_width=2, frame_color=color.new(#6272a4, 0))
        table.cell(g_rsi_table, 0, 0, '  TF  ', text_color=color.new(#bd93f9, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
        table.cell(g_rsi_table, 1, 0, '    RSI     ', text_color=color.new(#bd93f9, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
        if show_col1
            table.cell(g_rsi_table, col_p1, 0, '        ' + str.tostring(i_table_col1_level, '#') + '        ', text_color=color.new(#bd93f9, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
        if show_col2
            table.cell(g_rsi_table, col_p2, 0, '        ' + str.tostring(i_table_col2_level, '#') + '        ', text_color=color.new(#bd93f9, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
    for i = 0 to 4
        rsi_val = g_rsi_values.get(i)
        [bg, txt_clr] = f_rsi_color(rsi_val)
        table.cell(g_rsi_table, 0, i+1, g_rsi_tfs_display.get(i), bgcolor=bg, text_color=txt_clr, text_size=size.small)
        table.cell(g_rsi_table, 1, i+1, na(rsi_val) ? "â€”" : str.tostring(rsi_val, "#.##"), bgcolor=bg, text_color=txt_clr, text_size=size.normal)
        if show_col1
            p1 = f_rsi_calc_price(i_table_col1_level, g_rsi_close.get(i), g_rsi_auc.get(i), g_rsi_adc.get(i))
            bg1 = (not na(rsi_val) and rsi_val <= i_table_col1_level) ? color.new(#3de1c7, 20) : color.new(#282a36, 0)
            txt1 = (not na(rsi_val) and rsi_val <= i_table_col1_level) ? color.new(#282a36, 0) : color.new(#f8f8f2, 0)
            table.cell(g_rsi_table, col_p1, i+1, na(p1) ? "â€”" : str.tostring(p1, format.mintick), bgcolor=bg1, text_color=txt1, text_size=size.normal)
        if show_col2
            p2 = f_rsi_calc_price(i_table_col2_level, g_rsi_close.get(i), g_rsi_auc.get(i), g_rsi_adc.get(i))
            bg2 = (not na(rsi_val) and rsi_val >= i_table_col2_level) ? color.new(#ff4d8d, 20) : color.new(#282a36, 0)
            txt2 = (not na(rsi_val) and rsi_val >= i_table_col2_level) ? color.new(#282a36, 0) : color.new(#f8f8f2, 0)
            table.cell(g_rsi_table, col_p2, i+1, na(p2) ? "â€”" : str.tostring(p2, format.mintick), bgcolor=bg2, text_color=txt2, text_size=size.normal)





// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š LÃ“GICA ICT - HTF CANDLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
int cnt = 0
int last = f_htf_enabled()
int offset = settings.offset

if htf1.settings.show and f_valid_timeframe(htf1.settings.htf)
    bool showTrace = (settings.trace_anchor == 'First Timeframe') or (settings.trace_anchor == 'Last Timeframe' and settings.max_sets == 1)
    htf1.UpdateTime(offset)
    htf1.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf1.candles.size() * settings.width + (htf1.candles.size() > 0 ? (htf1.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

if htf2.settings.show and f_valid_timeframe(htf2.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf2.UpdateTime(offset)
    htf2.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf2.candles.size() * settings.width + (htf2.candles.size() > 0 ? (htf2.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

if htf3.settings.show and f_valid_timeframe(htf3.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf3.UpdateTime(offset)
    htf3.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf3.candles.size() * settings.width + (htf3.candles.size() > 0 ? (htf3.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

if htf4.settings.show and f_valid_timeframe(htf4.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf4.UpdateTime(offset)
    htf4.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf4.candles.size() * settings.width + (htf4.candles.size() > 0 ? (htf4.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

if htf5.settings.show and f_valid_timeframe(htf5.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf5.UpdateTime(offset)
    htf5.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf5.candles.size() * settings.width + (htf5.candles.size() > 0 ? (htf5.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

if htf6.settings.show and f_valid_timeframe(htf6.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe')
    htf6.UpdateTime(offset)
    htf6.Monitor().Update(offset, showTrace).FindImbalance()

f_cleanup_candle_set(CandleSet candleSet) =>
    if candleSet.candles.size() > 0
        for i = candleSet.candles.size() - 1 to 0
            c = candleSet.candles.get(i)
            box.delete(c.body)
            line.delete(c.wick_up)
            line.delete(c.wick_down)
            if not na(c.dow_label)
                c.dow_label.delete()
        candleSet.candles.clear()
    if candleSet.imbalances.size() > 0
        for i = candleSet.imbalances.size() - 1 to 0
            box.delete(candleSet.imbalances.get(i).b)
        candleSet.imbalances.clear()
    if not na(candleSet.tfNameTop)
        candleSet.tfNameTop.delete()
        candleSet.tfNameTop := na
    if not na(candleSet.tfNameBottom)
        candleSet.tfNameBottom.delete()
        candleSet.tfNameBottom := na
    if not na(candleSet.tfTimerTop)
        candleSet.tfTimerTop.delete()
        candleSet.tfTimerTop := na
    if not na(candleSet.tfTimerBottom)
        candleSet.tfTimerBottom.delete()
        candleSet.tfTimerBottom := na
// [FIX v1.2.2] Garbage collection ao desativar HTF
if not htf1.settings.show and prev_show_htf1
    f_cleanup_candle_set(htf1)
if not htf2.settings.show and prev_show_htf2
    f_cleanup_candle_set(htf2)
if not htf3.settings.show and prev_show_htf3
    f_cleanup_candle_set(htf3)
if not htf4.settings.show and prev_show_htf4
    f_cleanup_candle_set(htf4)
if not htf5.settings.show and prev_show_htf5
    f_cleanup_candle_set(htf5)
if not htf6.settings.show and prev_show_htf6
    f_cleanup_candle_set(htf6)

// [FIX v1.2.0] Garbage collection: limpa tabela RSI quando feature desligada
if not i_table_show and not na(g_rsi_table)
    table.delete(g_rsi_table)
    g_rsi_table := na
    g_prev_col_config := 0

prev_show_htf1 := htf1.settings.show
prev_show_htf2 := htf2.settings.show
prev_show_htf3 := htf3.settings.show
prev_show_htf4 := htf4.settings.show
prev_show_htf5 := htf5.settings.show
prev_show_htf6 := htf6.settings.show
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” DEBUG MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// [FIX v1.2.0] Protegido contra NaN â€” usa nz() e na() checks

if i_fvg_debug
    if na(g_debug_table)
        g_debug_table := table.new(position.bottom_left, 2, 8, bgcolor=color.new(#282a36, 0), border_width=2, border_color=color.new(#bd93f9, 0))
        table.cell(g_debug_table, 0, 0, 'ğŸ” FVG Debug V1.2.2', text_color=color.new(#f8f8f2, 0), bgcolor=color.new(#6272a4, 0))
        table.merge_cells(g_debug_table, 0, 0, 1, 0)
    if barstate.islast
        activeCount = g_active_fvgs.size()
        table.cell(g_debug_table, 0, 1, 'FVGs Ativos:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 1, str.tostring(activeCount)+'/'+str.tostring(i_fvg_max_count), text_color=activeCount>12?color.new(#ffb86c, 0):color.new(#50fa7b, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 2, 'Modo:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 2, i_fvg_auto_threshold?'ğŸ“Š ATR':(i_fvg_adaptive_tf?'âš™ï¸ Adaptativo':'ğŸ“ Fixo'), text_color=color.new(#f8f8f2, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 3, 'Threshold:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 3, na(thresholdUsed) ? 'â€”' : str.tostring(nz(thresholdUsed, 0)*100,'#.###')+'%', text_color=color.new(#f8f8f2, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 4, 'ATR('+str.tostring(i_atr_period)+'):', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 4, na(atrValue) ? 'â€”' : str.tostring(atrValue, format.mintick), text_color=color.new(#8be9fd, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 5, 'MitigaÃ§Ã£o:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 5, i_fvg_mitigation_type, text_color=color.new(#50fa7b, 0), text_size=size.tiny)
        table.cell(g_debug_table, 0, 6, 'TF Seconds:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 6, str.tostring(g_tf_seconds), text_color=color.new(#f8f8f2, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 7, 'Ãšltimo FVG:', text_color=color.new(#6272a4, 0), text_size=size.small)
        if activeCount > 0
            lastFvg = g_active_fvgs.get(0)
            fvgSize = math.abs(lastFvg.top - lastFvg.bottom)
            fvgPct = (fvgSize / math.max(lastFvg.bottom, syminfo.mintick)) * 100
            table.cell(g_debug_table, 1, 7, (lastFvg.isBull?'ğŸŸ¢ Bull':'ğŸ”´ Bear')+' ('+str.tostring(fvgPct,'#.##')+'%)', text_color=lastFvg.isBull?color.new(#50fa7b, 0):color.new(#ff5555, 0), text_size=size.tiny)
        else
            table.cell(g_debug_table, 1, 7, 'Nenhum', text_color=color.new(#6272a4, 0), text_size=size.small)
else if not i_fvg_debug and not na(g_debug_table)
    g_debug_table.delete()
    g_debug_table := na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”” ALERTAS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// g_prev_fvg_time: snapshot do g_last_fvg_time ANTES de adicionar novo FVG
// g_last_fvg_time: atualizado APÃ“S adicionar novo FVG
// NecessÃ¡rio para que alertcondition detecte o FVG recÃ©m-adicionado
bool fvg_can_be_added = g_active_fvgs.size() < i_fvg_max_count
bool fvg_is_new = detectedFvg.birthTime > nz(g_prev_fvg_time, 0)
bool new_bull_fvg = i_fvg_enabled and barstate.isconfirmed and isBull and fvg_is_new and fvg_can_be_added and detectedFvg.isActive
bool new_bear_fvg = i_fvg_enabled and barstate.isconfirmed and isBear and fvg_is_new and fvg_can_be_added and detectedFvg.isActive

alertcondition(new_bull_fvg, title="Novo FVG de Alta", message="ğŸŸ¢ Novo FVG de Alta Detectado!")
alertcondition(new_bear_fvg, title="Novo FVG de Baixa", message="ğŸ”´ Novo FVG de Baixa Detectado!")
alertcondition(ta.crossover(rsi_current, 70.0), title="RSI Sobrecomprado (>70)", message="âš ï¸ RSI Cruzou 70 para cima")
alertcondition(ta.crossunder(rsi_current, 30.0), title="RSI Sobrevendido (<30)", message="âš ï¸ RSI Cruzou 30 para baixo")
