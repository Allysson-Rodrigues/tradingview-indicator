//@version=6
indicator('ICT + FVG + RSI V1.1.8', shorttitle="ICT + FVG Pro 1.1.8", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500, max_bars_back=5000)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ METADADOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Nome:        ICT + FVG + RSI
// VersÃ£o:      1.1.8
// Atualizado:  2025-12-20
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“‹ DESCRIÃ‡ÃƒO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Indicador completo que combina mÃºltiplas ferramentas de anÃ¡lise tÃ©cnica:
//
// ğŸ•¯ï¸ HTF CANDLES (Multi-Timeframe)
//    - Exibe candles de atÃ© 6 timeframes superiores no grÃ¡fico
//    - Suporta trace lines para OHLC do candle atual
//    - Detecta FVG e VI nos candles MTF
//    - Timer de contagem regressiva para fechamento do candle
//
// ğŸ¯ FVG (Fair Value Gap) NO GRÃFICO
//    - Detecta gaps de valor justo (bullish e bearish)
//    - TrÃªs modos de threshold: Fixo, Adaptativo por TF, ou ATR automÃ¡tico
//    - Sistema de mitigaÃ§Ã£o configurÃ¡vel (25%, 50%, 100%)
//    - ExpiraÃ§Ã£o automÃ¡tica por idade
//
// ğŸ“Š RSI MULTI-TIMEFRAME
//    - Tabela com RSI de 5 timeframes (5m, 15m, 1h, 4h, 1D)
//    - Cores indicativas de zonas (sobrevendido/sobrecomprado)
//    - CÃ¡lculo de preÃ§os-alvo para nÃ­veis RSI especÃ­ficos
//    - Linhas de preÃ§o RSI plotÃ¡veis (25, 30, 50, 70, 75, custom)
//
// ğŸ“ˆ EMA
//    - MÃ©dia mÃ³vel exponencial customizÃ¡vel
//
// ğŸ”” ALERTAS
//    - Novo FVG de Alta/Baixa
//    - RSI cruzando 70 para cima (sobrecomprado)
//    - RSI cruzando 30 para baixo (sobrevendido)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“œ CHANGELOG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V1.1.8 (2025-12-20)
//    - Robustez: ProteÃ§Ã£o contra divisÃ£o por zero no mÃ©todo isExpired
//    - Robustez: Bounds checking e fallback para dados RSI invÃ¡lidos
//    - Robustez: Tabela RSI recria automaticamente ao mudar colunas
//    - Extensibilidade: ATR Period agora Ã© configurÃ¡vel via input
//    - Extensibilidade: Fuso horÃ¡rio configurÃ¡vel (5 opÃ§Ãµes)
//    - Extensibilidade: Timeframes da tabela RSI agora sÃ£o dinÃ¢micos
//
// V1.1.6 (2025-12-19)
//    - OtimizaÃ§Ã£o: CÃ¡lculo condicional simplificado de nÃ­veis RSI
//    - RefatoraÃ§Ã£o: Cache RSI sÃ³ calcula nÃ­veis com linhas visuais ativas
//    - UX: VersÃ£o do Debug table atualizada para refletir versÃ£o atual
//
// V1.1.5 (2025-12-18)
//    - Novo: Checkboxes para ativar/desativar colunas RSI na tabela
//    - UX melhorada: controle independente de exibiÃ§Ã£o e nÃ­vel RSI
//
// V1.1.4 (2025-12-18)
//    - OtimizaÃ§Ã£o: RSI_ALPHA prÃ©-calculado como constante var
//    - CorreÃ§Ã£o: f_fvg_detect() agora normaliza gap size pelo ATR quando ATR Auto estÃ¡ ativo
//    - Evita falsos positivos em ativos volÃ¡teis ou com preÃ§os baixos
//    - ConsistÃªncia lÃ³gica: threshold e gap size usam mesma unidade de medida
//
// V1.1.3 (2025-12-17)
//    - Tooltips adicionados a todos os 60+ inputs do indicador
//    - DocumentaÃ§Ã£o inline melhorada para melhor UX no TradingView
//    - DescriÃ§Ãµes claras em portuguÃªs para cada parÃ¢metro
//
// V1.1.2 (2025-12-16)
//    - CorreÃ§Ã£o crÃ­tica: box.set_top/bottom agora usa math.max/min
//    - Bug corrigido: candles HTF de alta renderizam corretamente
//    - Melhoria: corpo do candle sempre com coordenadas corretas
//
// V1.1.1 (2025-12-16)
//    - Timer histÃ³rico alterado de '---' para '--:--' (formato tempo)
//    - FindImbalance otimizado: processa apenas em novo candle HTF
//    - Removido box.copy() + box.delete() desnecessÃ¡rio (performance)
//    - Tracking via idx para evitar duplicaÃ§Ã£o de imbalances
//    - SincronizaÃ§Ã£o visual: FVG boxes acompanham movimento dos candles HTF
//    - CorreÃ§Ã£o: condiÃ§Ã£o FVG >= 3 (detecta com exatamente 3 candles)
//
// V1.1 (2025-12-15)
//    - Removido scale=scale.none para melhor visualizaÃ§Ã£o dos candles
//    - Timer alterado de 'n/a' para '---' em dados histÃ³ricos
//    - DocumentaÃ§Ã£o completa adicionada
//
// V1.0 (2025-12-14)
//    - FusÃ£o inicial: ICT HTF Candles + FVG + RSI + MTF
//    - Sistema de cache RSI implementado
//    - Debug mode para FVG adicionado
//    - Alertas configurados
//

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”¢ CONSTANTES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PerÃ­odo para cÃ¡lculo do ATR usado no threshold automÃ¡tico de FVG
// NOTA: ATR_PERIOD removido - agora configurÃ¡vel via i_atr_period
// NÃºmero mÃ¡ximo de linhas na tabela RSI (1 header + 5 TFs + 1 buffer)
const int MAX_TABLE_ROWS = 7
// Limite de FVGs processados por tick para evitar timeout
const int MAX_ITER_PER_BAR = 20
// MÃ¡ximo de FVGs removidos por tick para evitar loops longos
const int MAX_REMOVALS = 10
// ConversÃ£o de segundos para milissegundos
const int MS_PER_SECOND = 1000 

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¦ TYPES (ICT)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @type Candle - Representa um candle HTF com dados OHLC e objetos grÃ¡ficos
// @field o float - PreÃ§o de abertura
// @field c float - PreÃ§o de fechamento
// @field h float - PreÃ§o mÃ¡ximo (high)
// @field l float - PreÃ§o mÃ­nimo (low)
// @field o_time int - Timestamp de abertura
// @field o_idx int - Bar index de abertura
// @field c_idx int - Bar index de fechamento
// @field h_idx int - Bar index onde ocorreu o high
// @field l_idx int - Bar index onde ocorreu o low
// @field dow string - Nome do dia da semana (para candles diÃ¡rios)
// @field body box - Objeto box do corpo do candle
// @field wick_up line - Linha do pavio superior
// @field wick_down line - Linha do pavio inferior
// @field dow_label label - Label com nome do dia
type Candle
    float o
    float c
    float h
    float l
    int o_time
    int o_idx
    int c_idx
    int h_idx
    int l_idx
    string dow
    box body
    line wick_up
    line wick_down
    label dow_label

// @type Trace - Linhas de rastreamento OHLC conectando candle atual ao HTF
// @field o line - Linha do preÃ§o de abertura
// @field c line - Linha do preÃ§o de fechamento
// @field h line - Linha do preÃ§o mÃ¡ximo
// @field l line - Linha do preÃ§o mÃ­nimo
// @field o_l label - Label com valor do open
// @field c_l label - Label com valor do close
// @field h_l label - Label com valor do high
// @field l_l label - Label com valor do low
type Trace
    line o
    line c
    line h
    line l
    label o_l
    label c_l
    label h_l
    label l_l

// @type Imbalance - Representa um FVG ou VI detectado nos candles HTF
// @field b box - Objeto box visual do imbalance
// @field idx int - Bar index do candle onde foi detectado (para tracking)
// @field arr_i1 int - Ãndice do candle 1 no array (mais novo)
// @field arr_i2 int - Ãndice do candle 2 no array (mais antigo)
type Imbalance
    box b
    int idx
    int arr_i1
    int arr_i2

// @type CandleSettings - ConfiguraÃ§Ãµes de um timeframe HTF especÃ­fico
// @field show bool - Se o timeframe estÃ¡ visÃ­vel
// @field htf string - String do timeframe (ex: '5', '15', '60', '1D')
// @field max_display int - NÃºmero mÃ¡ximo de candles a exibir
type CandleSettings
    bool show
    string htf
    int max_display

type Settings
    int max_sets
    color bull_body
    color bull_border
    color bull_wick
    color bear_body
    color bear_border
    color bear_wick
    int offset
    int buffer
    int htf_buffer
    int width
    bool daily_name
    bool trace_show
    color trace_o_color
    string trace_o_style
    int trace_o_size
    color trace_c_color
    string trace_c_style
    int trace_c_size
    color trace_h_color
    string trace_h_style
    int trace_h_size
    color trace_l_color
    string trace_l_style
    int trace_l_size
    string trace_anchor
    bool label_show
    color label_color
    string label_size
    string label_position
    string label_alignment
    bool fvg_show
    color fvg_color
    bool vi_show
    color vi_color
    bool htf_label_show
    color htf_label_color
    string htf_label_size
    bool htf_timer_show
    color htf_timer_color
    string htf_timer_size
    color dow_color
    string dow_size

// @type CandleSet - Conjunto completo de candles e imbalances de um HTF
// @field candles array<Candle> - Array de candles (0=mais novo)
// @field imbalances array<Imbalance> - Array de FVGs/VIs detectados
// @field settings CandleSettings - ConfiguraÃ§Ãµes do timeframe
// @field tfNameTop label - Label com nome do TF no topo
// @field tfNameBottom label - Label com nome do TF na base
// @field tfTimerTop label - Label com timer no topo
// @field tfTimerBottom label - Label com timer na base
type CandleSet
    array<Candle> candles
    array<Imbalance> imbalances
    CandleSettings settings
    label tfNameTop
    label tfNameBottom
    label tfTimerTop
    label tfTimerBottom

// @type Helper - Objeto auxiliar para mÃ©todos sem estado
// @field name string - Nome do Ãºltimo mÃ©todo chamado (para debug)
type Helper
    string name = 'Helper'

// @type FVG - Fair Value Gap detectado no grÃ¡fico principal
// @field top float - PreÃ§o do topo do gap
// @field bottom float - PreÃ§o do fundo do gap
// @field isBull bool - true se bullish (gap para cima)
// @field birthTime int - Timestamp de criaÃ§Ã£o (xloc.bar_time)
// @field boxObj box - Objeto box visual
// @field mitigatedLine line - Linha de mitigaÃ§Ã£o (nÃ£o usado atualmente)
// @field isActive bool - Se o FVG ainda estÃ¡ ativo (nÃ£o mitigado/expirado)
type FVG
    float top
    float bottom
    bool isBull
    int birthTime
    box boxObj
    line mitigatedLine
    bool isActive

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ INPUTS - ICT HTF
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Settings settings = Settings.new()
var CandleSettings SettingsHTF1 = CandleSettings.new()
var CandleSettings SettingsHTF2 = CandleSettings.new()
var CandleSettings SettingsHTF3 = CandleSettings.new()
var CandleSettings SettingsHTF4 = CandleSettings.new()
var CandleSettings SettingsHTF5 = CandleSettings.new()
var CandleSettings SettingsHTF6 = CandleSettings.new()

string group_htf = "ğŸ“Š HTF Candles  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_style = "ğŸ¨ Styling  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_label = "ğŸ·ï¸ Labels  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_imbalance = "âš–ï¸ MTF Imbalances  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_trace = "ğŸ“ Trace Lines  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_ema = "ğŸ“ˆ EMA  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_rsi = "ğŸ“‰ RSI  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_table = "ğŸ“‹ Tabela RSI  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_fvg = "ğŸ¯ FVG GrÃ¡fico  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

// HTF Settings
SettingsHTF1.show := input.bool(true, 'HTF 1', inline='htf1', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 1')
htf_1 = input.timeframe('5', '', inline='htf1', group=group_htf)
SettingsHTF1.htf := htf_1
SettingsHTF1.max_display := input.int(10, '', inline='htf1', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF2.show := input.bool(true, 'HTF 2', inline='htf2', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 2')
htf_2 = input.timeframe('15', '', inline='htf2', group=group_htf)
SettingsHTF2.htf := htf_2
SettingsHTF2.max_display := input.int(8, '', inline='htf2', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF3.show := input.bool(true, 'HTF 3', inline='htf3', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 3')
htf_3 = input.timeframe('60', '', inline='htf3', group=group_htf)
SettingsHTF3.htf := htf_3
SettingsHTF3.max_display := input.int(6, '', inline='htf3', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF4.show := input.bool(true, 'HTF 4', inline='htf4', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 4')
htf_4 = input.timeframe('240', '', inline='htf4', group=group_htf)
SettingsHTF4.htf := htf_4
SettingsHTF4.max_display := input.int(5, '', inline='htf4', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF5.show := input.bool(true, 'HTF 5', inline='htf5', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 5 (Daily)')
htf_5 = input.timeframe('1D', '', inline='htf5', group=group_htf)
SettingsHTF5.htf := htf_5
SettingsHTF5.max_display := input.int(5, '', inline='htf5', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF6.show := input.bool(true, 'HTF 6', inline='htf6', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 6 (Weekly)')
htf_6 = input.timeframe('1W', '', inline='htf6', group=group_htf)
SettingsHTF6.htf := htf_6
SettingsHTF6.max_display := input.int(3, '', inline='htf6', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

settings.max_sets := input.int(3, 'Limite HTFs', minval=1, maxval=6, group=group_htf, tooltip='NÃºmero mÃ¡ximo de grupos HTF a exibir simultaneamente (1-6)')
i_timezone = input.string('America/Sao_Paulo', 'Fuso HorÃ¡rio', options=['America/Sao_Paulo', 'America/New_York', 'Europe/London', 'Asia/Tokyo', 'UTC'], group=group_htf, tooltip='Fuso horÃ¡rio para cÃ¡lculo de datas e horÃ¡rios dos candles HTF')
i_auto_daily = input.bool(true, 'Daily Auto (>=1H)', group=group_htf, tooltip='Mostra MTF Daily apenas quando grÃ¡fico estÃ¡ em 1H ou acima')
i_auto_weekly = input.bool(true, 'Weekly Auto (>=4H)', group=group_htf, tooltip='Mostra MTF Weekly apenas quando grÃ¡fico estÃ¡ em 4H ou acima')

// LÃ³gica para mostrar Daily automaticamente (1H = 3600 segundos)
bool showDailyAuto = i_auto_daily and timeframe.in_seconds() >= 3600
if i_auto_daily
    SettingsHTF5.show := showDailyAuto

// LÃ³gica para mostrar Weekly automaticamente (4H = 14400 segundos)
bool showWeeklyAuto = i_auto_weekly and timeframe.in_seconds() >= 14400
if i_auto_weekly
    SettingsHTF6.show := showWeeklyAuto

// Styling
settings.bull_body := input.color(color.new(#089981, 70),'Body Bull/Bear', inline='body', group=group_style, tooltip='Cor do corpo dos candles de alta (esquerda) e baixa (direita)')
settings.bear_body := input.color(color.new(#f23645, 70), '', inline='body', group=group_style)
settings.bull_border := input.color(color.new(#000000,70), 'Border', inline='borders', group=group_style, tooltip='Cor da borda dos candles de alta e baixa')
settings.bear_border := input.color(color.new(#000000,70), '', inline='borders', group=group_style)
settings.bull_wick := input.color(color.new(color.black, 70), 'Wick', inline='wick', group=group_style, tooltip='Cor dos pavios dos candles de alta e baixa')
settings.bear_wick := input.color(color.new(color.black, 70), '', inline='wick', group=group_style)
settings.offset := input.int(30, 'Offset', minval=1, group=group_style, tooltip='DistÃ¢ncia horizontal entre o Ãºltimo candle do grÃ¡fico e os HTF candles')
settings.buffer := input.int(1, 'Buffer', minval=1, maxval=4, group=group_style, tooltip='EspaÃ§amento entre candles individuais dentro de um grupo HTF')
settings.htf_buffer := input.int(5, 'HTF Buffer', minval=1, maxval=10, group=group_style, tooltip='EspaÃ§amento entre grupos de diferentes timeframes')
settings.width := input.int(1, 'Width', minval=1, maxval=4, group=group_style, tooltip='Largura visual dos candles HTF (multiplicado por 2)') * 2

// Labels
settings.htf_label_show := input.bool(true, 'HTF Label', inline='HTFlabel', group=group_label, tooltip='Exibe o nome do timeframe acima/abaixo dos candles')
settings.htf_label_color := input.color(color.new(#000000, 0), '', inline='HTFlabel', group=group_label)
settings.htf_label_size := input.string(size.normal, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='HTFlabel', group=group_label)
settings.label_position := input.string("Top", 'Position', options=['Both', 'Top', 'Bottom'], group=group_label, tooltip='PosiÃ§Ã£o do label: Topo, Base ou Ambos')
settings.label_alignment := input.string("Follow Candles", "Alignment", options=['Align', 'Follow Candles'], group=group_label, tooltip='Align: labels alinhados | Follow: labels seguem posiÃ§Ã£o dos candles')
settings.htf_timer_show := input.bool(true, 'Timer', inline='timer', group=group_label, tooltip='Exibe contagem regressiva atÃ© o fechamento do candle HTF')
settings.htf_timer_color := input.color(color.new(color.black, 10), '', inline='timer', group=group_label)
settings.htf_timer_size := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='timer', group=group_label)
settings.daily_name := input.bool(true, 'DOW Label', inline='dow', group=group_label, tooltip='Exibe nome do dia da semana (Seg, Ter...) para candles diÃ¡rios')
settings.dow_color := input.color(color.black, '', inline='dow', group=group_label)
settings.dow_size := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='dow', group=group_label)

// MTF Imbalances
settings.fvg_show := input.bool(true, 'FVG MTF', inline='fvg', group=group_imbalance, tooltip='Detecta e exibe Fair Value Gaps nos candles HTF')
settings.fvg_color := input.color(color.rgb(120, 123, 134, 85),'', inline='fvg', group=group_imbalance)
settings.vi_show := input.bool(false, 'VI MTF', inline='vi', group=group_imbalance, tooltip='Detecta e exibe Volume Imbalances nos candles HTF')
settings.vi_color := input.color(color.new(color.red, 50), '', inline='vi', group=group_imbalance)

// Trace Lines
settings.trace_show := input.bool(false, 'Trace Lines', group=group_trace, tooltip='Desenha linhas conectando OHLC do candle atual atÃ© os HTF candles') 
settings.trace_o_color := input.color(color.new(color.gray, 50), 'Open', inline='1', group=group_trace, tooltip='Linha do preÃ§o de abertura: cor, estilo e espessura')
settings.trace_o_style := input.string('Â·Â·Â·Â·', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='1', group=group_trace)
settings.trace_o_size := input.int(1, '', options=[1, 2, 3, 4], inline='1', group=group_trace)
settings.trace_c_color := input.color(color.new(color.gray, 50), 'Close', inline='2', group=group_trace, tooltip='Linha do preÃ§o de fechamento: cor, estilo e espessura')
settings.trace_c_style := input.string('Â·Â·Â·Â·', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='2', group=group_trace)
settings.trace_c_size := input.int(1, '', options=[1, 2, 3, 4], inline='2', group=group_trace)
settings.trace_h_color := input.color(color.new(color.gray, 50), 'High', inline='3', group=group_trace, tooltip='Linha da mÃ¡xima: cor, estilo e espessura')
settings.trace_h_style := input.string('â¯â¯â¯', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='3', group=group_trace)
settings.trace_h_size := input.int(1, '', options=[1, 2, 3, 4], inline='3', group=group_trace)
settings.trace_l_color := input.color(color.new(color.gray, 50), 'Low', inline='4', group=group_trace, tooltip='Linha da mÃ­nima: cor, estilo e espessura')
settings.trace_l_style := input.string('â¯â¯â¯', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='4', group=group_trace)
settings.trace_l_size := input.int(1, '', options=[1, 2, 3, 4], inline='4', group=group_trace)
settings.trace_anchor := input.string('First Timeframe', 'Anchor', options=['First Timeframe', 'Last Timeframe'], group=group_trace, tooltip='Define qual grupo HTF recebe as trace lines')
settings.label_show := input.bool(false, 'Price Labels', inline='label', group=group_trace, tooltip='Exibe labels com os preÃ§os OHLC nas extremidades das linhas')
settings.label_color := input.color(color.new(color.black, 10), '', inline='label', group=group_trace)
settings.label_size := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='label', group=group_trace)

// EMA
i_showEMA = input.bool(false, 'âš¡ Ativar EMA', group=group_ema, tooltip='Ativa a MÃ©dia MÃ³vel Exponencial no grÃ¡fico')
i_emaLength = input.int(26, 'PerÃ­odo', minval=1, maxval=500, group=group_ema, tooltip='NÃºmero de barras para cÃ¡lculo da EMA (padrÃ£o: 26)')
i_emaColor = input.color(#4a4a4acc, 'Cor', group=group_ema, tooltip='Cor da linha EMA')
i_emaWidth = input.int(1, 'Espessura', minval=1, maxval=5, group=group_ema, tooltip='Espessura da linha EMA')
i_emaSource = input.source(close, 'Fonte', group=group_ema, tooltip='Fonte de dados para cÃ¡lculo (close, open, high, low, hl2, etc.)')

// RSI
i_rsi_length = input.int(14, 'PerÃ­odo RSI', minval=2, maxval=200, group=group_rsi, tooltip='PerÃ­odo para cÃ¡lculo do RSI (padrÃ£o: 14)')
i_show_rsi_25 = input.bool(false, 'Exibir NÃ­vel 25', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 25')
i_show_rsi_30 = input.bool(false, 'Exibir NÃ­vel 30', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 30 (sobrevendido)')
i_show_rsi_50 = input.bool(false, 'Exibir NÃ­vel 50', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 50 (neutro)')
i_show_rsi_70 = input.bool(false, 'Exibir NÃ­vel 70', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 70 (sobrecomprado)')
i_show_rsi_75 = input.bool(false, 'Exibir NÃ­vel 75', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 75')
i_show_rsi_custom = input.bool(false, 'â­ Exibir RSI Customizado', group=group_rsi, tooltip='Plota linha horizontal para um nÃ­vel RSI personalizado')
i_rsi_custom_level = input.float(40, 'NÃ­vel RSI Customizado', minval=1, maxval=99, step=1, group=group_rsi, tooltip='Define o nÃ­vel RSI desejado para a linha customizada (1-99)')
i_rsi_custom_color = input.color(color.new(#ff9800, 0), 'Cor RSI Customizado', group=group_rsi, tooltip='Cor da linha RSI customizada')
i_rsi_max_deviation = input.float(0.30, 'Desvio MÃ¡ximo (%)', minval=0.10, maxval=1.00, step=0.05, group=group_rsi, tooltip='Limite mÃ¡ximo de variaÃ§Ã£o de preÃ§o para cÃ¡lculos RSI (evita valores extremos)')

// Tabela RSI
i_table_show = input.bool(true, 'Exibir Tabela', group=group_table, tooltip='Ativa a tabela multi-timeframe com valores RSI e preÃ§os-alvo')
i_rsi_tf1 = input.timeframe('5', 'TF 1', inline='rsi_tf1', group=group_table, tooltip='Timeframe 1 da tabela RSI')
i_rsi_tf1_name = input.string('5m', '', inline='rsi_tf1', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf2 = input.timeframe('15', 'TF 2', inline='rsi_tf2', group=group_table, tooltip='Timeframe 2 da tabela RSI')
i_rsi_tf2_name = input.string('15m', '', inline='rsi_tf2', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf3 = input.timeframe('60', 'TF 3', inline='rsi_tf3', group=group_table, tooltip='Timeframe 3 da tabela RSI')
i_rsi_tf3_name = input.string('1h', '', inline='rsi_tf3', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf4 = input.timeframe('240', 'TF 4', inline='rsi_tf4', group=group_table, tooltip='Timeframe 4 da tabela RSI')
i_rsi_tf4_name = input.string('4h', '', inline='rsi_tf4', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf5 = input.timeframe('D', 'TF 5', inline='rsi_tf5', group=group_table, tooltip='Timeframe 5 da tabela RSI')
i_rsi_tf5_name = input.string('1D', '', inline='rsi_tf5', group=group_table, tooltip='Nome exibido na tabela')
i_table_show_col1 = input.bool(false, 'Exibir Coluna 1', inline='col1', group=group_table, tooltip='Ativa/desativa a coluna de preÃ§o para o nÃ­vel RSI 1')
i_table_col1_level = input.float(30, '', minval=1, maxval=99, step=1, inline='col1', group=group_table, tooltip='NÃ­vel RSI para calcular preÃ§o (ex: 30, 40, 50). Mostra o preÃ§o que o ativo precisa atingir para RSI chegar neste nÃ­vel')
i_table_show_col2 = input.bool(false, 'Exibir Coluna 2', inline='col2', group=group_table, tooltip='Ativa/desativa a coluna de preÃ§o para o nÃ­vel RSI 2')
i_table_col2_level = input.float(70, '', minval=1, maxval=99, step=1, inline='col2', group=group_table, tooltip='NÃ­vel RSI para calcular preÃ§o (ex: 70, 65, 55). Mostra o preÃ§o que o ativo precisa atingir para RSI chegar neste nÃ­vel')
i_table_position = input.string('top_right', 'PosiÃ§Ã£o', options=['top_right', 'top_left', 'bottom_right', 'bottom_left'], group=group_table, tooltip='PosiÃ§Ã£o da tabela RSI no grÃ¡fico')


// FVG GrÃ¡fico
i_fvg_enabled = input.bool(true, 'âš¡ Ativar FVG', group=group_fvg, tooltip='Ativa detecÃ§Ã£o e exibiÃ§Ã£o de Fair Value Gaps no grÃ¡fico principal')
i_fvg_auto_threshold = input.bool(false, 'Threshold ATR Auto', group=group_fvg, tooltip='Quando ativo, usa ATR(14) para calcular automaticamente o limiar mÃ­nimo de FVG')
i_fvg_threshold = input.float(0.3, 'Limiar (%)', minval=0.01, maxval=10, step=0.05, group=group_fvg, tooltip='Tamanho mÃ­nimo do gap em % para ser considerado FVG (usado quando ATR Auto estÃ¡ desativado)')
i_fvg_adaptive_tf = input.bool(true, 'Adaptativo TF', group=group_fvg, tooltip='Multiplica o limiar baseado no timeframe (TFs maiores = limiares maiores)')
i_fvg_max_multiplier = input.float(5.0, 'Mult. MÃ¡ximo', minval=1.0, maxval=20.0, step=0.5, group=group_fvg, tooltip='Limite mÃ¡ximo do multiplicador adaptativo por timeframe')
i_fvg_timeframe = input.timeframe('', 'Timeframe', group=group_fvg, tooltip='Timeframe para detecÃ§Ã£o de FVG (vazio = usa TF do grÃ¡fico atual)')
i_fvg_extend_bars = input.int(15, 'ExtensÃ£o', minval=5, maxval=200, group=group_fvg, tooltip='Quantas barras a caixa FVG se estende para a direita')
i_fvg_max_count = input.int(8, 'MÃ¡ximo FVGs', minval=1, maxval=50, group=group_fvg, tooltip='NÃºmero mÃ¡ximo de FVGs ativos simultaneamente no grÃ¡fico')
i_fvg_max_age = input.int(300, 'Idade MÃ¡x', minval=50, maxval=1000, group=group_fvg, tooltip='Remove FVGs nÃ£o mitigados apÃ³s esta quantidade de barras')
i_fvg_bull_color = input.color(color.new(#089981, 85), 'Cor Alta', group=group_fvg, tooltip='Cor das caixas FVG bullish (gap para cima)')
i_fvg_bear_color = input.color(color.new(#f23645, 85), 'Cor Baixa', group=group_fvg, tooltip='Cor das caixas FVG bearish (gap para baixo)')
i_fvg_mitigation_type = input.string('50% (Meio)', 'MitigaÃ§Ã£o', options=['50% (Meio)', '100% (Completo)', '25% (Conservador)'], group=group_fvg, tooltip='Define quando um FVG Ã© considerado mitigado: 25% (conservador), 50% (meio) ou 100% (completa)')
i_fvg_debug = input.bool(false, 'Debug Mode', group=group_fvg, tooltip='Exibe tabela de debug com informaÃ§Ãµes tÃ©cnicas sobre os FVGs')
i_atr_period = input.int(14, 'ATR PerÃ­odo', minval=5, maxval=50, group=group_fvg, tooltip='PerÃ­odo do ATR usado no threshold automÃ¡tico de FVG')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ VARIÃVEIS GLOBAIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ICT Candles
var array<Candle> candles_1 = array.new<Candle>(0)
var array<Candle> candles_2 = array.new<Candle>(0)
var array<Candle> candles_3 = array.new<Candle>(0)
var array<Candle> candles_4 = array.new<Candle>(0)
var array<Candle> candles_5 = array.new<Candle>(0)
var array<Candle> candles_6 = array.new<Candle>(0)

var array<Imbalance> imbalances_1 = array.new<Imbalance>()
var array<Imbalance> imbalances_2 = array.new<Imbalance>()
var array<Imbalance> imbalances_3 = array.new<Imbalance>()
var array<Imbalance> imbalances_4 = array.new<Imbalance>()
var array<Imbalance> imbalances_5 = array.new<Imbalance>()
var array<Imbalance> imbalances_6 = array.new<Imbalance>()

var CandleSet htf1 = CandleSet.new()
htf1.settings := SettingsHTF1
htf1.candles := candles_1
htf1.imbalances := imbalances_1

var CandleSet htf2 = CandleSet.new()
htf2.settings := SettingsHTF2
htf2.candles := candles_2
htf2.imbalances := imbalances_2

var CandleSet htf3 = CandleSet.new()
htf3.settings := SettingsHTF3
htf3.candles := candles_3
htf3.imbalances := imbalances_3

var CandleSet htf4 = CandleSet.new()
htf4.settings := SettingsHTF4
htf4.candles := candles_4
htf4.imbalances := imbalances_4

var CandleSet htf5 = CandleSet.new()
htf5.settings := SettingsHTF5
htf5.candles := candles_5
htf5.imbalances := imbalances_5

var CandleSet htf6 = CandleSet.new()
htf6.settings := SettingsHTF6
htf6.candles := candles_6
htf6.imbalances := imbalances_6

Helper helper = Helper.new()
var Trace trace = Trace.new()
color color_transparent = #ffffff00

// RSI
var float RSI_ALPHA = 1.0 / i_rsi_length  // PrÃ©-calculado para otimizaÃ§Ã£o (constante)
var array<string> g_rsi_tfs = array.from(i_rsi_tf1, i_rsi_tf2, i_rsi_tf3, i_rsi_tf4, i_rsi_tf5)
var array<string> g_rsi_tfs_display = array.from(i_rsi_tf1_name, i_rsi_tf2_name, i_rsi_tf3_name, i_rsi_tf4_name, i_rsi_tf5_name)
var float[] g_rsi_values = array.new_float(5, na)
var float[] g_rsi_close = array.new_float(5, na)
var float[] g_rsi_auc = array.new_float(5, na)
var float[] g_rsi_adc = array.new_float(5, na)
var float g_cached_rsi25 = na
var float g_cached_rsi30 = na
var float g_cached_rsi50 = na
var float g_cached_rsi70 = na
var float g_cached_rsi75 = na
var float g_cached_rsi_custom = na
var int g_last_calc_bar = -1
var table g_rsi_table = na
var int g_prev_col_config = 0  // Robustez: rastreia configuraÃ§Ã£o de colunas para recriar tabela

// FVG GrÃ¡fico
var array<FVG> g_active_fvgs = array.new<FVG>()
var int g_prev_fvg_time = 0
var int g_last_fvg_time = 0
var array<int> g_fvg_to_remove = array.new<int>()
var int g_tf_seconds = 0
var table g_debug_table = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡Ã•ES AUXILIARES - ICT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @method Converte string de estilo para constante line.style
// @param style string - Estilo visual ('â¯â¯â¯', '----', 'Â·Â·Â·Â·')
// @returns line.style - Constante de estilo de linha
method LineStyle(Helper helper, string style) =>
    helper.name := style
    switch style
        '----' => line.style_dashed
        'Â·Â·Â·Â·' => line.style_dotted
        => line.style_solid

// @method Converte Ã­ndice do dia da semana para nome em portuguÃªs
// @param index int - Ãndice (1=Seg, 2=Ter, ..., 7=Dom)
// @returns string - Nome abreviado do dia da semana
method DayofWeek(Helper helper, int index) =>
    helper.name := 'DOW'
    switch
        index == 1 => 'Seg'
        index == 2 => 'Ter'
        index == 3 => 'Qua'
        index == 4 => 'Qui'
        index == 5 => 'Sex'
        index == 6 => 'SÃ¡b'
        index == 7 => 'Dom'
        na(index) => ''

// @method Valida se um timeframe HTF Ã© vÃ¡lido para exibiÃ§Ã£o
// @param HTF string - Timeframe a validar
// @returns bool - true se TF do grÃ¡fico < HTF e sÃ£o mÃºltiplos inteiros
// Regra: HTF deve ser maior que TF atual e divisÃ­vel exatamente
method ValidTimeframe(Helper helper, string HTF) =>
    helper.name := HTF
    if timeframe.in_seconds(HTF) >= timeframe.in_seconds('D') and timeframe.in_seconds(HTF) > timeframe.in_seconds()
        true
    else
        n1 = timeframe.in_seconds()
        n2 = timeframe.in_seconds(HTF)
        n1 < n2 and math.round(n2 / n1) == n2 / n1

// @method Calcula tempo restante atÃ© fechamento do candle HTF
// @param HTF string - Timeframe para calcular
// @returns string - Tempo formatado (ex: '05:32', '01:23:45', '2D 12:30:00')
// Retorna '--:--' em dados histÃ³ricos (nÃ£o realtime)
method RemainingTime(Helper helper, string HTF) =>
    helper.name := HTF
    if barstate.isrealtime
        timeRemaining = (time_close(HTF) - timenow) / 1000
        days = math.floor(timeRemaining / 86400)
        hours = math.floor((timeRemaining - days * 86400) / 3600)
        minutes = math.floor((timeRemaining - days * 86400 - hours * 3600) / 60)
        seconds = math.floor(timeRemaining - days * 86400 - hours * 3600 - minutes * 60)
        r = str.tostring(seconds, '00')
        if minutes > 0 or hours > 0 or days > 0
            r := str.tostring(minutes, '00') + ':' + r
        if hours > 0 or days > 0
            r := str.tostring(hours, '00') + ':' + r
        if days > 0
            r := str.tostring(days) + 'D ' + r
        r
    else
        '--:--'

// @method Formata nome do timeframe para exibiÃ§Ã£o
// @param HTF string - Timeframe a formatar
// @returns string - Nome formatado (ex: '5m', '1H', '1D')
method HTFName(Helper helper, string HTF) =>
    helper.name := 'HTFName'
    seconds = timeframe.in_seconds(HTF)
    if seconds < 60
        str.tostring(seconds) + 's'
    else if seconds / 60 < 60
        str.tostring(seconds / 60) + 'm'
    else if seconds / 60 / 60 < 24
        str.tostring(seconds / 60 / 60) + 'H'
    else
        HTF

// @method Conta quantos timeframes HTF estÃ£o ativos
// @returns int - NÃºmero de HTFs ativos (limitado por settings.max_sets)
method HTFEnabled(Helper helper) =>
    helper.name := 'HTFEnabled'
    int enabled = 0
    enabled += htf1.settings.show ? 1 : 0
    enabled += htf2.settings.show ? 1 : 0
    enabled += htf3.settings.show ? 1 : 0
    enabled += htf4.settings.show ? 1 : 0
    enabled += htf5.settings.show ? 1 : 0
    enabled += htf6.settings.show ? 1 : 0
    math.min(enabled, settings.max_sets)

// @method Encontra o preÃ§o mais alto em um conjunto de candles
// @param candles array<Candle> - Array de candles a analisar
// @param h float - Valor inicial/mÃ­nimo para comparaÃ§Ã£o
// @returns float - Maior high encontrado
method CandleSetHigh(Helper helper, array<Candle> candles, float h) =>
    helper.name := 'CandleSetHigh'
    float _h = h
    if candles.size() > 0
        for i = 0 to candles.size() - 1
            if candles.get(i).h > _h
                _h := candles.get(i).h
    _h

// @method Encontra o preÃ§o mais baixo em um conjunto de candles
// @param candles array<Candle> - Array de candles a analisar
// @param l float - Valor inicial/mÃ¡ximo para comparaÃ§Ã£o
// @returns float - Menor low encontrado
method CandleSetLow(Helper helper, array<Candle> candles, float l) =>
    helper.name := 'CandleSetLow'
    float _l = l
    if candles.size() > 0
        for i = 0 to candles.size() - 1
            if candles.get(i).l < _l
                _l := candles.get(i).l
    _l

// @method Encontra o high global de todos os HTF candles ativos
// @returns float - Maior high entre todos os candles HTF visÃ­veis
// Usado para alinhar labels quando label_alignment='Align'
method CandlesHigh(Helper helper) =>
    h = 0.0
    int cnt = 0
    int last = helper.HTFEnabled()
    if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
        h := helper.CandleSetHigh(htf1.candles, h), cnt += 1
    if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf2.candles, h), cnt += 1
    if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf3.candles, h), cnt += 1
    if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf4.candles, h), cnt += 1
    if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf5.candles, h), cnt += 1
    if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf6.candles, h)
    h

// @method Encontra o low global de todos os HTF candles ativos
// @param h float - Valor inicial (geralmente resultado de CandlesHigh)
// @returns float - Menor low entre todos os candles HTF visÃ­veis
// Usado para alinhar labels quando label_alignment='Align'
method CandlesLow(Helper helper, float h) =>
    l = h
    int cnt = 0
    int last = helper.HTFEnabled()
    if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
        l := helper.CandleSetLow(htf1.candles, l), cnt += 1
    if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf2.candles, l), cnt += 1
    if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf3.candles, l), cnt += 1
    if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf4.candles, l), cnt += 1
    if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf5.candles, l), cnt += 1
    if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf6.candles, l)
    l

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡Ã•ES AUXILIARES - RSI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Calcula o perÃ­odo EMA para o cÃ¡lculo interno do RSI
// @returns int - PerÃ­odo EMA (mÃ­nimo 1)
f_rsi_ema_length() => math.max(1, 2 * i_rsi_length - 1)

// @function Retorna cores de fundo e texto baseadas no valor RSI
// @param r float - Valor do RSI (0-100)
// @returns [color, color] - [cor de fundo, cor do texto]
// Escala: <20 verde escuro, 20-30 verde, 30-45 verde claro, 
//         45-55 neutro, 55-70 rosa, 70-80 vermelho, >80 vermelho escuro
f_rsi_color(float r) =>
    switch
        na(r) => [color.new(#272727, 0), color.white]
        r < 20 => [color.new(#006400, 0), color.white]
        r < 30 => [color.new(#00A863, 20), color.white]
        r < 45 => [color.new(#ceecce, 5), color.rgb(0, 0, 0)]
        r <= 55 => [color.new(#ffffff, 0), color.rgb(0, 0, 0)]
        r < 70 => [color.new(#f7d1cf, 0), color.rgb(0, 0, 0)]
        r < 80 => [color.new(#c25e5e, 15), color.white]
        => [color.new(#b10000, 0), color.white]

// @function Valida se os parÃ¢metros para cÃ¡lculo RSI sÃ£o vÃ¡lidos
// @param c float - PreÃ§o de fechamento
// @param au float - MÃ©dia de ganhos (Average Up)
// @param ad float - MÃ©dia de perdas (Average Down)
// @returns bool - true se todos os valores sÃ£o vÃ¡lidos
f_rsi_is_valid(float c, float au, float ad) =>
    not na(c) and not na(au) and not na(ad) and c > 0 and au >= 0 and ad >= 0

// @function Calcula o preÃ§o necessÃ¡rio para atingir um nÃ­vel RSI especÃ­fico
// @param target_rsi float - NÃ­vel RSI desejado (1-99)
// @param close_val float - PreÃ§o de fechamento atual
// @param auc_val float - MÃ©dia de ganhos EMA atual
// @param adc_val float - MÃ©dia de perdas EMA atual
// @returns float - PreÃ§o calculado (limitado por i_rsi_max_deviation) ou na
// Algoritmo: Usa fÃ³rmula inversa do RSI com suavizaÃ§Ã£o EMA
// Para RSI < 50: calcula perda necessÃ¡ria
// Para RSI >= 50: calcula ganho necessÃ¡rio
f_rsi_calc_price(float target_rsi, float close_val, float auc_val, float adc_val) =>
    if not f_rsi_is_valid(close_val, auc_val, adc_val) or target_rsi <= 0 or target_rsi >= 100
        na
    else
        alpha = RSI_ALPHA  // Usa constante prÃ©-calculada
        denominator = 100.0 - target_rsi
        if denominator == 0
            na
        else
            target_rs = target_rsi / denominator
            float calc_price = na
            if target_rsi < 50
                // Para RSI baixo: precisa de perda (preÃ§o cair)
                new_avg_up = (1 - alpha) * auc_val
                new_avg_down = target_rs == 0 ? na : new_avg_up / target_rs
                d_loss = na(new_avg_down) ? na : (new_avg_down - (1 - alpha) * adc_val) / alpha
                calc_price := na(d_loss) ? na : close_val - d_loss
            else
                // Para RSI alto: precisa de ganho (preÃ§o subir)
                new_avg_down = (1 - alpha) * adc_val
                new_avg_up = target_rs * new_avg_down
                d_gain = (new_avg_up - (1 - alpha) * auc_val) / alpha
                calc_price := close_val + d_gain
            if na(calc_price)
                na
            else
                // Limita o preÃ§o ao desvio mÃ¡ximo permitido
                min_p = close_val * (1 - i_rsi_max_deviation)
                max_p = close_val * (1 + i_rsi_max_deviation)
                math.max(min_p, math.min(max_p, calc_price))

// @function Empacota dados RSI para request.security
// @returns [float, float, float, float] - [close, rsi, auc, adc]
// Usado para buscar dados de mÃºltiplos timeframes de forma eficiente
f_rsi_pack() =>
    emaLen = f_rsi_ema_length()
    [close, ta.rsi(close, i_rsi_length), ta.ema(math.max(close - close[1], 0), emaLen), ta.ema(math.max(close[1] - close, 0), emaLen)]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡Ã•ES AUXILIARES - FVG GRÃFICO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Calcula multiplicador de threshold baseado no timeframe
// @param tf_sec int - Timeframe em segundos
// @returns float - Multiplicador (0.5 a 8.0, limitado por i_fvg_max_multiplier)
// InterpolaÃ§Ã£o linear entre timeframes para sensibilidade adequada:
// 1m=0.5, 5m=0.75, 15m=1.0, 1H=1.5, 4H=2.2, 1D=4.0, >1D=8.0
f_fvg_get_tf_multiplier(int tf_sec) =>
    float result = switch
        tf_sec <= 60 => 0.5
        tf_sec <= 300 => 0.5 + (tf_sec - 60) * (0.75 - 0.5) / (300 - 60)
        tf_sec <= 900 => 0.75 + (tf_sec - 300) * (1.0 - 0.75) / (900 - 300)
        tf_sec <= 3600 => 1.0 + (tf_sec - 900) * (1.5 - 1.0) / (3600 - 900)
        tf_sec <= 14400 => 1.5 + (tf_sec - 3600) * (2.2 - 1.5) / (14400 - 3600)
        tf_sec <= 86400 => 2.2 + (tf_sec - 14400) * (4.0 - 2.2) / (86400 - 14400)
        => 8.0
    math.min(i_fvg_max_multiplier, result)

// @function Calcula o nÃ­vel de preÃ§o para mitigaÃ§Ã£o do FVG
// @param top float - Topo do FVG
// @param bottom float - Fundo do FVG
// @param mitType string - Tipo de mitigaÃ§Ã£o ('25%', '50%', '100%')
// @param isBull bool - Se Ã© FVG bullish
// @returns float - NÃ­vel de preÃ§o para considerar mitigado
f_fvg_get_mitigation_level(float top, float bottom, string mitType, bool isBull) =>
    if mitType == '100% (Completo)'
        isBull ? bottom : top
    else if mitType == '25% (Conservador)'
        isBull ? top - (top - bottom) * 0.25 : bottom + (top - bottom) * 0.25
    else
        (top + bottom) / 2.0

// @method Desenha o FVG no grÃ¡fico como uma box
// @param this FVG - InstÃ¢ncia do FVG
// Cria box do birthTime atÃ© birthTime + extensÃ£o configurada
method draw(FVG this) =>
    if not na(this) and this.isActive
        x1 = this.birthTime
        x2 = this.birthTime + (g_tf_seconds * MS_PER_SECOND * i_fvg_extend_bars)
        boxColor = this.isBull ? i_fvg_bull_color : i_fvg_bear_color
        this.boxObj := box.new(left=x1, top=this.top, right=x2, bottom=this.bottom, xloc=xloc.bar_time, border_color=na, bgcolor=boxColor)

// @method Remove o FVG do grÃ¡fico e marca como inativo
// @param this FVG - InstÃ¢ncia do FVG
// @param wasMitigated bool - Se foi mitigado (vs expirado)
// @param mitigationPrice float - PreÃ§o onde foi mitigado
method remove(FVG this, bool wasMitigated, float mitigationPrice) =>
    if not na(this)
        if not na(this.boxObj)
            this.boxObj.delete()
            this.boxObj := na
        this.isActive := false

// @method Verifica se o FVG foi mitigado pelo preÃ§o atual
// @param this FVG - InstÃ¢ncia do FVG
// @returns [bool, float] - [foi mitigado, nÃ­vel de mitigaÃ§Ã£o]
// Bull FVG: mitigado quando low <= nÃ­vel
// Bear FVG: mitigado quando high >= nÃ­vel
method checkMitigation(FVG this) =>
    bool isMitigated = false
    float mitigationLevel = f_fvg_get_mitigation_level(this.top, this.bottom, i_fvg_mitigation_type, this.isBull)
    if time > this.birthTime
        isMitigated := this.isBull ? (low <= mitigationLevel) : (high >= mitigationLevel)
    [isMitigated, mitigationLevel]

// @method Verifica se o FVG expirou por idade
// @param this FVG - InstÃ¢ncia do FVG
// @returns bool - true se passou de i_fvg_max_age barras
method isExpired(FVG this) =>
    if g_tf_seconds <= 0
        false
    else
        barsAge = int((time - this.birthTime) / (g_tf_seconds * MS_PER_SECOND))
        barsAge > i_fvg_max_age

// @function Detecta FVGs no grÃ¡fico atual
// @returns [bool, bool, FVG, float, float] - [isBull, isBear, fvg, threshold, atr]
// FVG Bullish: gap entre high[2] e low (preÃ§o pulou para cima)
// FVG Bearish: gap entre low[2] e high (preÃ§o pulou para baixo)
// Threshold pode ser fixo, adaptativo por TF, ou baseado em ATR
// Quando ATR Auto: gap e threshold normalizados pelo ATR (mais robusto para ativos volÃ¡teis)
// Quando Threshold Fixo: gap e threshold normalizados pelo preÃ§o (%)
f_fvg_detect() =>
    float atr_value = i_fvg_auto_threshold or i_fvg_debug ? ta.atr(i_atr_period) : na
    float threshold = na
    float bullGapSize = na
    float bearGapSize = na
    
    if i_fvg_auto_threshold
        // Modo ATR: normaliza gap pelo ATR para consistÃªncia
        // Threshold padrÃ£o = 1.0 ATR (gap deve ser >= 1 ATR para ser significativo)
        float atr_safe = math.max(atr_value, syminfo.mintick)
        threshold := 1.0
        if i_fvg_adaptive_tf
            threshold := threshold * f_fvg_get_tf_multiplier(g_tf_seconds)
        bullGapSize := (low - high[2]) / atr_safe
        bearGapSize := (low[2] - high) / atr_safe
    else
        // Modo Threshold Fixo: normaliza gap pelo preÃ§o (%)
        threshold := i_fvg_threshold / 100.0
        if i_fvg_adaptive_tf
            threshold := threshold * f_fvg_get_tf_multiplier(g_tf_seconds)
        bullGapSize := (low - high[2]) / math.max(high[2], syminfo.mintick)
        bearGapSize := (low[2] - high) / math.max(low[2], syminfo.mintick)
    
    // Detecta gap bullish (preÃ§o subiu deixando gap)
    isBullFvg = low > high[2] and bullGapSize > threshold
    // Detecta gap bearish (preÃ§o caiu deixando gap)
    isBearFvg = high < low[2] and bearGapSize > threshold
    bool hasEnoughBars = bar_index >= 2 and not na(time[2])
    FVG newFvg = isBullFvg and hasEnoughBars ? FVG.new(low, high[2], true, time[2], na, na, true) :
                 isBearFvg and hasEnoughBars ? FVG.new(low[2], high, false, time[2], na, na, true) :
                 FVG.new(na, na, false, 0, na, na, false)
    [isBullFvg, isBearFvg, newFvg, threshold, atr_value]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ MÃ‰TODOS ICT - CandleSet
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Estes mÃ©todos gerenciam a exibiÃ§Ã£o dos candles HTF no grÃ¡fico.
// Cada CandleSet representa um timeframe superior (HTF1-HTF6).

// @method Atualiza o timer de contagem regressiva do candle HTF
// @param candleSet CandleSet - Conjunto de candles do timeframe
// @param offset int - Offset horizontal para posicionamento
// @returns CandleSet - Retorna o prÃ³prio conjunto para encadeamento
method UpdateTime(CandleSet candleSet, int offset) =>
    if settings.htf_timer_show and (barstate.isrealtime or barstate.islast)
        string tmr = '(' + helper.RemainingTime(candleSet.settings.htf) + ')'
        if not na(candleSet.tfTimerTop)
            candleSet.tfTimerTop.set_text(tmr)
        if not na(candleSet.tfTimerBottom)
            candleSet.tfTimerBottom.set_text(tmr)
    candleSet

// @method Reordena posiÃ§Ã£o dos candles HTF conforme novo offset
// @param candleSet CandleSet - Conjunto de candles do timeframe
// @param offset int - Offset horizontal base
// @returns CandleSet - Retorna o prÃ³prio conjunto para encadeamento
// Atualiza posiÃ§Ã£o de boxes, wicks, labels e cria labels HTF se necessÃ¡rio
method Reorder(CandleSet candleSet, int offset) =>
    size = candleSet.candles.size()
    if size > 0
        for i = size - 1 to 0
            Candle candle = candleSet.candles.get(i)
            t_buffer = offset + (settings.width + settings.buffer) * (size - i - 1)
            box.set_left(candle.body, bar_index + t_buffer)
            box.set_right(candle.body, bar_index + settings.width + t_buffer)
            line.set_x1(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x1(candle.wick_down, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_down, bar_index + settings.width / 2 + t_buffer)
            if settings.daily_name
                if not na(candle.dow_label)
                    candle.dow_label.set_y(candle.h)
                    candle.dow_label.set_x(bar_index + settings.width / 2 + t_buffer)
                else
                    candle.dow_label := label.new(bar_index + settings.width / 2 + t_buffer, candle.h, candle.dow, color=color_transparent, textcolor=settings.dow_color, style=label.style_label_down, size=settings.dow_size)
    top = 0.0
    bottom = 0.0
    if settings.label_alignment == 'Align'
        top := helper.CandlesHigh()
        bottom := helper.CandlesLow(top)
    if settings.label_alignment == 'Follow Candles'
        top := helper.CandleSetHigh(candleSet.candles, 0)
        bottom := helper.CandleSetLow(candleSet.candles, top)
    left = bar_index + offset + (settings.width + settings.buffer) * (size - 1) / 2
    if settings.htf_label_show
        string lblt = helper.HTFName(candleSet.settings.htf)
        string lbll = lblt
        if settings.htf_timer_show
            lblt := lblt + '\n'
            lbll := '\n' + lbll
        if settings.daily_name
            lblt := lblt + '\n'
        string tmr = '(' + helper.RemainingTime(candleSet.settings.htf) + ')' + (settings.daily_name ? '\n' : '')
        if settings.label_position == 'Both' or settings.label_position == 'Top'
            if not na(candleSet.tfNameTop)
                candleSet.tfNameTop.set_xy(left, top)
            else
                candleSet.tfNameTop := label.new(left, top, lblt, color=color_transparent, textcolor=settings.htf_label_color, style=label.style_label_down, size=settings.htf_label_size)
            if settings.htf_timer_show
                if not na(candleSet.tfTimerTop)
                    candleSet.tfTimerTop.set_xy(left, top)
                else
                    candleSet.tfTimerTop := label.new(left, top, tmr, color=color_transparent, textcolor=settings.htf_timer_color, style=label.style_label_down, size=settings.htf_timer_size)
        if settings.label_position == 'Both' or settings.label_position == 'Bottom'
            if not na(candleSet.tfNameBottom)
                candleSet.tfNameBottom.set_xy(left, bottom)
            else
                candleSet.tfNameBottom := label.new(left, bottom, lbll, color=color_transparent, textcolor=settings.htf_label_color, style=label.style_label_up, size=settings.htf_label_size)
            if settings.htf_timer_show
                if not na(candleSet.tfTimerBottom)
                    candleSet.tfTimerBottom.set_xy(left, bottom)
                else
                    candleSet.tfTimerBottom := label.new(left, bottom, tmr, color=color_transparent, textcolor=settings.htf_timer_color, style=label.style_label_up, size=settings.htf_timer_size)
    
    // Atualizar posiÃ§Ã£o dos Imbalances (FVG/VI) para acompanhar os candles
    if candleSet.imbalances.size() > 0
        for i = 0 to candleSet.imbalances.size() - 1
            Imbalance imb = candleSet.imbalances.get(i)
            // Recalcular posiÃ§Ãµes baseadas nos Ã­ndices originais do array
            // Nota: Candle i2 estÃ¡ Ã  ESQUERDA (novo), Candle i1 Ã  DIREITA (velho) no array
            // Mas visualmente no grÃ¡fico: Direita Ã© futuro.
            // O array Ã© [0=mais_novo, 1=antigo...]
            // Reorder usa: t_buffer = offset + ... * (size - i - 1)
            // Quanto menor o i (mais novo), maior o t_buffer (mais Ã  direita)
            
            // PosiÃ§Ã£o Candle 2 (i+2 ou i+1) - Esquerda visual (mais antigo)
            t_buf2 = offset + (settings.width + settings.buffer) * (size - imb.arr_i2 - 1)
            // PosiÃ§Ã£o Candle 1 (i) - Direita visual (mais novo)
            t_buf1 = offset + (settings.width + settings.buffer) * (size - imb.arr_i1 - 1)
            
            // Atualiza coordenadas X da box para acompanhar candles
            box.set_left(imb.b, bar_index + t_buf2)
            box.set_right(imb.b, bar_index + t_buf1 + settings.width)
    candleSet

// @method Detecta e desenha FVGs e VIs nos candles HTF (OTIMIZADO)
// @param candleSet CandleSet - Conjunto de candles do timeframe
// @returns CandleSet - Retorna o prÃ³prio conjunto para encadeamento
// OTIMIZAÃ‡ÃƒO: MantÃ©m histÃ³rico imutÃ¡vel, detecta em todos os candles apenas quando novo HTF candle
// FVG: Gap entre candle[0] e candle[2]
// VI: Volume Imbalance entre candles adjacentes
method FindImbalance(CandleSet candleSet) =>
    int candleCount = candleSet.candles.size()
    
    if candleCount >= 3 and (barstate.isrealtime or barstate.islast)
        // Obter Ã­ndice do Ãºltimo candle para tracking
        Candle lastCandle = candleSet.candles.get(candleCount - 1)
        int currentCandleIdx = lastCandle.o_idx
        
        // Verificar se jÃ¡ processamos este candle (evita recriaÃ§Ã£o a cada tick)
        int lastProcessedIdx = candleSet.imbalances.size() > 0 ? candleSet.imbalances.get(candleSet.imbalances.size() - 1).idx : -1
        bool isNewCandle = currentCandleIdx > lastProcessedIdx or lastProcessedIdx == -1
        
        // SÃ³ recriar imbalances quando hÃ¡ novo candle HTF
        if isNewCandle
            // Limpar imbalances antigos
            if candleSet.imbalances.size() > 0
                for i = candleSet.imbalances.size() - 1 to 0
                    Imbalance del = candleSet.imbalances.get(i)
                    box.delete(del.b)
                    candleSet.imbalances.pop()
            
            // Detectar FVG em TODOS os candles
            if candleCount >= 3 and settings.fvg_show
                for i = 0 to candleCount - 3 by 1
                    candle1 = candleSet.candles.get(i)
                    candle2 = candleSet.candles.get(i + 2)
                    // FVG Bullish (gap para cima)
                    if candle1.l > candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_left(candle2.body), candle2.h, box.get_right(candle1.body), candle1.l, bgcolor=settings.fvg_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 2
                        candleSet.imbalances.push(imb)
                    // FVG Bearish (gap para baixo)
                    if candle1.h < candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_right(candle1.body), candle1.h, box.get_left(candle2.body), candle2.l, bgcolor=settings.fvg_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 2
                        candleSet.imbalances.push(imb)
            
            // Detectar VI em TODOS os candles
            if candleCount > 2 and settings.vi_show
                for i = 0 to candleCount - 2 by 1
                    candle1 = candleSet.candles.get(i)
                    candle2 = candleSet.candles.get(i + 1)
                    // VI Bullish (gap ascendente)
                    if candle1.l < candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_left(candle2.body), math.min(candle1.o, candle1.c), box.get_right(candle1.body), math.max(candle2.o, candle2.c), bgcolor=settings.vi_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 1
                        candleSet.imbalances.push(imb)
                    // VI Bearish (gap descendente)
                    if candle1.h > candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_right(candle1.body), math.min(candle2.o, candle2.c), box.get_left(candle2.body), math.max(candle1.o, candle1.c), bgcolor=settings.vi_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 1
                        candleSet.imbalances.push(imb)
    
    candleSet


// @method Monitora mudanÃ§as de candle HTF e cria novos candles
// @param candleSet CandleSet - Conjunto de candles do timeframe
// @returns CandleSet - Retorna o prÃ³prio conjunto para encadeamento
// Detecta novo candle via ta.change(time) e gerencia cleanup de candles antigos
method Monitor(CandleSet candleSet) =>
    HTFBarTime = time(candleSet.settings.htf, i_timezone)
    isNewHTFCandle = ta.change(HTFBarTime) > 0
    if isNewHTFCandle
        Candle candle = Candle.new()
        candle.o := open, candle.c := close, candle.h := high, candle.l := low
        candle.o_time := time, candle.o_idx := bar_index, candle.c_idx := bar_index
        candle.h_idx := bar_index, candle.l_idx := bar_index
        candle.dow := switch
            candleSet.settings.htf == '1W' => 'Sem ' + str.tostring(weekofyear(time, i_timezone))
            candleSet.settings.htf == '1D' => helper.DayofWeek(dayofweek(time_tradingday, i_timezone))
            str.tonumber(candleSet.settings.htf) < 60 => str.format_time(candle.o_time, 'm', i_timezone)
            str.tonumber(candleSet.settings.htf) >= 60 => str.format_time(candle.o_time, 'H', i_timezone)
            => ''
        bull = candle.c > candle.o
        candle.body := box.new(bar_index, math.max(candle.o, candle.c), bar_index + 2, math.min(candle.o, candle.c), bull ? settings.bull_border : settings.bear_border, 1, bgcolor=bull ? settings.bull_body : settings.bear_body)
        candle.wick_up := line.new(bar_index + 1, candle.h, bar_index, math.max(candle.o, candle.c), color=bull ? settings.bull_wick : settings.bear_wick)
        candle.wick_down := line.new(bar_index + 1, math.min(candle.o, candle.c), bar_index, candle.l, color=bull ? settings.bull_wick : settings.bear_wick)
        candleSet.candles.unshift(candle)
        if candleSet.candles.size() > candleSet.settings.max_display
            Candle delCandle = array.pop(candleSet.candles)
            box.delete(delCandle.body)
            line.delete(delCandle.wick_up)
            line.delete(delCandle.wick_down)
            if not na(delCandle.dow_label)
                delCandle.dow_label.delete()
    candleSet

// @method Atualiza OHLC do candle atual e desenha trace lines
// @param candleSet CandleSet - Conjunto de candles do timeframe
// @param offset int - Offset horizontal base
// @param showTrace bool - Se deve desenhar as trace lines OHLC
// @returns CandleSet - Retorna o prÃ³prio conjunto para encadeamento
// Atualiza high/low se novos extremos, atualiza close a cada tick
method Update(CandleSet candleSet, int offset, bool showTrace) =>
    if candleSet.candles.size() > 0
        Candle candle = candleSet.candles.first()
        candle.h_idx := high > candle.h ? bar_index : candle.h_idx
        candle.h := high > candle.h ? high : candle.h
        candle.l_idx := low < candle.l ? bar_index : candle.l_idx
        candle.l := low < candle.l ? low : candle.l
        candle.c := close
        candle.c_idx := bar_index
        bull = candle.c > candle.o
        box.set_top(candle.body, math.max(candle.o, candle.c)), box.set_bottom(candle.body, math.min(candle.o, candle.c))
        box.set_bgcolor(candle.body, bull ? settings.bull_body : settings.bear_body)
        box.set_border_color(candle.body, bull ? settings.bull_border : settings.bear_border)
        line.set_color(candle.wick_up, bull ? settings.bull_wick : settings.bear_wick)
        line.set_color(candle.wick_down, bull ? settings.bull_wick : settings.bear_wick)
        line.set_y1(candle.wick_up, candle.h), line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
        line.set_y1(candle.wick_down, candle.l), line.set_y2(candle.wick_down, math.min(candle.o, candle.c))
        if barstate.isrealtime or barstate.islast
            candleSet.Reorder(offset)
            if settings.trace_show and showTrace
                if bar_index - candle.o_idx < 5000
                    if na(trace.o)
                        trace.o := line.new(candle.o_idx, candle.o, box.get_left(candle.body), candle.o, xloc=xloc.bar_index, color=settings.trace_o_color, style=helper.LineStyle(settings.trace_o_style), width=settings.trace_o_size)
                    else
                        line.set_xy1(trace.o, candle.o_idx, candle.o), line.set_xy2(trace.o, box.get_left(candle.body), candle.o)
                    if settings.label_show
                        if na(trace.o_l)
                            trace.o_l := label.new(box.get_right(candle.body), candle.o, str.tostring(candle.o), textalign=text.align_center, style=label.style_label_left, size=settings.label_size, color=color_transparent, textcolor=settings.label_color)
                        else
                            label.set_xy(trace.o_l, box.get_right(candle.body), candle.o), label.set_text(trace.o_l, str.tostring(candle.o))
                if bar_index - candle.c_idx < 5000
                    if na(trace.c)
                        trace.c := line.new(candle.c_idx, candle.c, box.get_left(candle.body), candle.c, xloc=xloc.bar_index, color=settings.trace_c_color, style=helper.LineStyle(settings.trace_c_style), width=settings.trace_c_size)
                    else
                        line.set_xy1(trace.c, candle.c_idx, candle.c), line.set_xy2(trace.c, box.get_left(candle.body), candle.c)
                    if settings.label_show
                        if na(trace.c_l)
                            trace.c_l := label.new(box.get_right(candle.body), candle.c, str.tostring(candle.c), textalign=text.align_center, style=label.style_label_left, size=settings.label_size, color=color_transparent, textcolor=settings.label_color)
                        else
                            label.set_xy(trace.c_l, box.get_right(candle.body), candle.c), label.set_text(trace.c_l, str.tostring(candle.c))
                if bar_index - candle.h_idx < 5000
                    if na(trace.h)
                        trace.h := line.new(candle.h_idx, candle.h, line.get_x1(candle.wick_up), candle.h, xloc=xloc.bar_index, color=settings.trace_h_color, style=helper.LineStyle(settings.trace_h_style), width=settings.trace_h_size)
                    else
                        line.set_xy1(trace.h, candle.h_idx, candle.h), line.set_xy2(trace.h, line.get_x1(candle.wick_up), candle.h)
                    if settings.label_show
                        if na(trace.h_l)
                            trace.h_l := label.new(box.get_right(candle.body), candle.h, str.tostring(candle.h), textalign=text.align_center, style=label.style_label_left, size=settings.label_size, color=color_transparent, textcolor=settings.label_color)
                        else
                            label.set_xy(trace.h_l, box.get_right(candle.body), candle.h), label.set_text(trace.h_l, str.tostring(candle.h))
                if bar_index - candle.l_idx < 5000
                    if na(trace.l)
                        trace.l := line.new(candle.l_idx, candle.l, line.get_x1(candle.wick_down), candle.l, xloc=xloc.bar_index, color=settings.trace_l_color, style=helper.LineStyle(settings.trace_l_style), width=settings.trace_l_size)
                    else
                        line.set_xy1(trace.l, candle.l_idx, candle.l), line.set_xy2(trace.l, line.get_x1(candle.wick_down), candle.l)
                    if settings.label_show
                        if na(trace.l_l)
                            trace.l_l := label.new(box.get_right(candle.body), candle.l, str.tostring(candle.l), textalign=text.align_center, style=label.style_label_left, size=settings.label_size, color=color_transparent, textcolor=settings.label_color)
                        else
                            label.set_xy(trace.l_l, box.get_right(candle.body), candle.l), label.set_text(trace.l_l, str.tostring(candle.l))
    candleSet

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š CÃLCULOS & REQUEST.SECURITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ema_value = ta.ema(i_emaSource, i_emaLength)
rsiEmaLength = f_rsi_ema_length()
rsi_current = ta.rsi(close, i_rsi_length)
auc_current = ta.ema(math.max(close - close[1], 0), rsiEmaLength)
adc_current = ta.ema(math.max(close[1] - close, 0), rsiEmaLength)

for i = 0 to g_rsi_tfs.size() - 1
    [c, r, au, ad] = request.security(syminfo.tickerid, g_rsi_tfs.get(i), f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
    // Robustez: bounds checking + fallback para dados invÃ¡lidos
    if i >= 0 and i < g_rsi_close.size()
        g_rsi_close.set(i, nz(c, close))
        g_rsi_values.set(i, nz(r, 50.0))
        g_rsi_auc.set(i, nz(au, 0.0))
        g_rsi_adc.set(i, nz(ad, 0.0))


tfFinal = i_fvg_timeframe == '' ? timeframe.period : i_fvg_timeframe
g_tf_seconds := timeframe.in_seconds(tfFinal)
[isBull, isBear, detectedFvg, thresholdUsed, atrValue] = request.security(syminfo.tickerid, tfFinal, f_fvg_detect(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš¡ LÃ“GICA PRINCIPAL - FVG GRÃFICO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// === BLOCO DE GERENCIAMENTO DE FVG ===
// ResponsÃ¡vel por:
// - Tracking de tempo para evitar duplicaÃ§Ã£o
// - CriaÃ§Ã£o de novos FVGs detectados
// - VerificaÃ§Ã£o de mitigaÃ§Ã£o (preÃ§o tocou o gap)
// - ExpiraÃ§Ã£o por idade (i_fvg_max_age barras)
// - Limpeza de objetos grÃ¡ficos (box.delete)

if barstate.isconfirmed
    g_prev_fvg_time := g_last_fvg_time

if i_fvg_enabled and barstate.isconfirmed and (isBull or isBear) and detectedFvg.birthTime > g_last_fvg_time
    if g_active_fvgs.size() < i_fvg_max_count and detectedFvg.isActive
        g_last_fvg_time := detectedFvg.birthTime
        detectedFvg.draw()
        g_active_fvgs.unshift(detectedFvg)

if i_fvg_enabled and (barstate.isconfirmed or barstate.islast) and g_active_fvgs.size() > 0
    if g_fvg_to_remove.size() > 0
        g_fvg_to_remove.clear()
    int arraySize = g_active_fvgs.size()
    int maxIter = math.min(arraySize, MAX_ITER_PER_BAR)
    for i = 0 to maxIter - 1
        if g_fvg_to_remove.size() >= MAX_REMOVALS
            break
        fvg = g_active_fvgs.get(i)
        if fvg.isActive
            [wasMitigated, mitigationPrice] = fvg.checkMitigation()
            wasExpired = fvg.isExpired()
            if wasMitigated or wasExpired
                fvg.remove(wasMitigated, mitigationPrice)
                g_fvg_to_remove.push(i)
    if g_fvg_to_remove.size() > 0
        g_fvg_to_remove.sort(order.descending)
        for i = 0 to g_fvg_to_remove.size() - 1
            g_active_fvgs.remove(g_fvg_to_remove.get(i))

// === BLOCO DE CACHE RSI ===
// ResponsÃ¡vel por:
// - Determinar quais nÃ­veis RSI precisam ser calculados (via flags use_rsi_XX)
// - Calcular preÃ§os-alvo apenas para linhas visuais ativas
// - Evitar recÃ¡lculo a cada tick (sÃ³ em barstate.isnew ou primeira vez)
// - Tabela RSI calcula seus prÃ³prios valores inline, nÃ£o usa este cache
bool use_rsi_25 = i_show_rsi_25
bool use_rsi_30 = i_show_rsi_30
bool use_rsi_50 = i_show_rsi_50
bool use_rsi_70 = i_show_rsi_70
bool use_rsi_75 = i_show_rsi_75
bool use_rsi_custom = i_show_rsi_custom

bool should_calculate = barstate.isnew or (barstate.islast and g_last_calc_bar != bar_index)
if should_calculate
    g_cached_rsi25 := use_rsi_25 ? f_rsi_calc_price(25.0, close, auc_current, adc_current) : na
    g_cached_rsi30 := use_rsi_30 ? f_rsi_calc_price(30.0, close, auc_current, adc_current) : na
    g_cached_rsi50 := use_rsi_50 ? f_rsi_calc_price(50.0, close, auc_current, adc_current) : na
    g_cached_rsi70 := use_rsi_70 ? f_rsi_calc_price(70.0, close, auc_current, adc_current) : na
    g_cached_rsi75 := use_rsi_75 ? f_rsi_calc_price(75.0, close, auc_current, adc_current) : na
    g_cached_rsi_custom := i_show_rsi_custom ? f_rsi_calc_price(i_rsi_custom_level, close, auc_current, adc_current) : na
    g_last_calc_bar := bar_index

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ RENDERIZAÃ‡ÃƒO VISUAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// EMA
plot(i_showEMA ? ema_value : na, title='EMA', color=i_emaColor, linewidth=i_emaWidth)

// RSI Lines
plot(i_show_rsi_25 ? g_cached_rsi25 : na, 'RSI 25', color.new(#00bcd4, 0), 1, plot.style_line)
plot(i_show_rsi_30 ? g_cached_rsi30 : na, 'RSI 30', color.new(color.red, 0), 1, plot.style_line)
plot(i_show_rsi_50 ? g_cached_rsi50 : na, 'RSI 50', color.new(color.gray, 0), 1, plot.style_line)
plot(i_show_rsi_70 ? g_cached_rsi70 : na, 'RSI 70', color.new(color.green, 0), 1, plot.style_line)
plot(i_show_rsi_75 ? g_cached_rsi75 : na, 'RSI 75', color.new(#ff5722, 0), 1, plot.style_line)
plot(i_show_rsi_custom ? g_cached_rsi_custom : na, 'RSI Custom', i_rsi_custom_color, 2, plot.style_line)

// === BLOCO DA TABELA RSI MTF ===
// ResponsÃ¡vel por:
// - Criar tabela dinamicamente (colunas variam conforme show_col1/col2)
// - Buscar RSI de 5 timeframes (5m, 15m, 1H, 4H, 1D)
// - Calcular preÃ§os-alvo para nÃ­veis customizados (col1_level, col2_level)
// - Aplicar cores baseadas em zonas RSI (verde=sobrevendido, vermelho=sobrecomprado)
// - Atualizar apenas em barstate.islast (evita processamento desnecessÃ¡rio)
bool show_col1 = i_table_show_col1
bool show_col2 = i_table_show_col2
int total_cols = 2
int col_p1 = na
if show_col1
    col_p1 := total_cols
    total_cols += 1
int col_p2 = na
if show_col2
    col_p2 := total_cols
    total_cols += 1

pos_rsi = switch i_table_position
    'top_right' => position.top_right
    'top_left' => position.top_left
    'bottom_right' => position.bottom_right
    => position.bottom_left

if i_table_show and barstate.islast
    // Robustez: recriar tabela se configuraÃ§Ã£o de colunas mudou
    int current_col_config = (show_col1 ? 1 : 0) + (show_col2 ? 2 : 0)
    if current_col_config != g_prev_col_config and not na(g_rsi_table)
        table.delete(g_rsi_table)
        g_rsi_table := na
    g_prev_col_config := current_col_config
    if na(g_rsi_table)
        g_rsi_table := table.new(pos_rsi, total_cols, MAX_TABLE_ROWS, bgcolor=color.rgb(26, 26, 26, 80), border_width=0, frame_width=1, frame_color=color.new(#000000,10))
        table.cell(g_rsi_table, 0, 0, '  TF  ', text_color=color.new(#000000,0), bgcolor=color.new(#ffffff,15), text_size=size.small)
        table.cell(g_rsi_table, 1, 0, '    RSI     ', text_color=color.new(#000000,0), bgcolor=color.new(#ffffff,15), text_size=size.small)
        if show_col1
            table.cell(g_rsi_table, col_p1, 0, '        ' + str.tostring(i_table_col1_level, '#') + '        ', text_color=color.new(#000000, 0), bgcolor=color.new(#ffffff,15), text_size=size.small)
        if show_col2
            table.cell(g_rsi_table, col_p2, 0, '        ' + str.tostring(i_table_col2_level, '#') + '        ', text_color=color.new(#000000, 0), bgcolor=color.new(#ffffff,15), text_size=size.small)
    for i = 0 to 4
        rsi_val = g_rsi_values.get(i)
        [bg, txt_clr] = f_rsi_color(rsi_val)
        table.cell(g_rsi_table, 0, i+1, g_rsi_tfs_display.get(i), bgcolor=bg, text_color=txt_clr, text_size=size.small)
        table.cell(g_rsi_table, 1, i+1, na(rsi_val) ? "â€”" : str.tostring(rsi_val, "#.##"), bgcolor=bg, text_color=txt_clr, text_size=size.normal)
        if show_col1
            p1 = f_rsi_calc_price(i_table_col1_level, g_rsi_close.get(i), g_rsi_auc.get(i), g_rsi_adc.get(i))
            bg1 = (not na(rsi_val) and rsi_val <= i_table_col1_level) ? color.new(#00A863, 20) : color.new(#2a2a2a, 20)
            table.cell(g_rsi_table, col_p1, i+1, na(p1) ? "â€”" : str.tostring(p1, format.mintick), bgcolor=bg1, text_color=color.white, text_size=size.normal)
        if show_col2
            p2 = f_rsi_calc_price(i_table_col2_level, g_rsi_close.get(i), g_rsi_auc.get(i), g_rsi_adc.get(i))
            bg2 = (not na(rsi_val) and rsi_val >= i_table_col2_level) ? color.new(#c25e5e, 15) : color.new(#2a2a2a, 20)
            table.cell(g_rsi_table, col_p2, i+1, na(p2) ? "â€”" : str.tostring(p2, format.mintick), bgcolor=bg2, text_color=color.white, text_size=size.normal)
 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š LÃ“GICA ICT - HTF CANDLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// === BLOCO DE RENDERIZAÃ‡ÃƒO HTF CANDLES ===
// ResponsÃ¡vel por:
// - Iterar sobre os 6 CandleSets (HTF1 a HTF6)
// - Validar timeframes (deve ser > TF atual)
// - Encadear mÃ©todos: UpdateTime -> Monitor -> Update -> FindImbalance
// - Calcular offsets horizontais acumulativos
// - Respeitar limite max_sets de grupos visÃ­veis

int cnt = 0
int last = helper.HTFEnabled()
int offset = settings.offset

if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
    bool showTrace = (settings.trace_anchor == 'First Timeframe') or (settings.trace_anchor == 'Last Timeframe' and settings.max_sets == 1)
    htf1.UpdateTime(offset)
    htf1.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf1.candles.size() * settings.width + (htf1.candles.size() > 0 ? (htf1.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf2.UpdateTime(offset)
    htf2.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf2.candles.size() * settings.width + (htf2.candles.size() > 0 ? (htf2.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf3.UpdateTime(offset)
    htf3.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf3.candles.size() * settings.width + (htf3.candles.size() > 0 ? (htf3.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf4.UpdateTime(offset)
    htf4.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf4.candles.size() * settings.width + (htf4.candles.size() > 0 ? (htf4.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf5.UpdateTime(offset)
    htf5.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf5.candles.size() * settings.width + (htf5.candles.size() > 0 ? (htf5.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe')
    htf6.UpdateTime(offset)
    htf6.Monitor().Update(offset, showTrace).FindImbalance()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” DEBUG MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if i_fvg_debug
    if na(g_debug_table)
        g_debug_table := table.new(position.bottom_left, 2, 8, bgcolor=color.new(#282a36, 0), border_width=2, border_color=color.new(#bd93f9, 0))
        table.cell(g_debug_table, 0, 0, 'ğŸ” FVG Debug V1.1.8', text_color=color.new(#f8f8f2, 0), bgcolor=color.new(#6272a4, 0))
        table.merge_cells(g_debug_table, 0, 0, 1, 0)
    if barstate.islast
        activeCount = g_active_fvgs.size()
        table.cell(g_debug_table, 0, 1, 'FVGs Ativos:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 1, str.tostring(activeCount)+'/'+str.tostring(i_fvg_max_count), text_color=activeCount>12?color.new(#ffb86c, 0):color.new(#50fa7b, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 2, 'Modo:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 2, i_fvg_auto_threshold?'ğŸ“Š ATR':(i_fvg_adaptive_tf?'âš™ï¸ Adaptativo':'ğŸ“ Fixo'), text_color=color.new(#f8f8f2, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 3, 'Threshold:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 3, str.tostring(thresholdUsed*100,'#.###')+'%', text_color=color.new(#f8f8f2, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 4, 'ATR(14):', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 4, str.tostring(atrValue, format.mintick), text_color=color.new(#8be9fd, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 5, 'MitigaÃ§Ã£o:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 5, i_fvg_mitigation_type, text_color=color.new(#50fa7b, 0), text_size=size.tiny)
        table.cell(g_debug_table, 0, 6, 'TF Seconds:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 6, str.tostring(g_tf_seconds), text_color=color.new(#f8f8f2, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 7, 'Ãšltimo FVG:', text_color=color.new(#6272a4, 0), text_size=size.small)
        if activeCount > 0
            lastFvg = g_active_fvgs.get(0)
            fvgSize = math.abs(lastFvg.top - lastFvg.bottom)
            fvgPct = (fvgSize / math.max(lastFvg.bottom, syminfo.mintick)) * 100
            table.cell(g_debug_table, 1, 7, (lastFvg.isBull?'ğŸŸ¢ Bull':'ğŸ”´ Bear')+' ('+str.tostring(fvgPct,'#.##')+'%)', text_color=lastFvg.isBull?color.new(#50fa7b, 0):color.new(#ff5555, 0), text_size=size.tiny)
        else
            table.cell(g_debug_table, 1, 7, 'Nenhum', text_color=color.new(#6272a4, 0), text_size=size.small)
else if not i_fvg_debug and not na(g_debug_table)
    g_debug_table.delete()
    g_debug_table := na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”” ALERTAS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// === BLOCO DE ALERTAS ===
// CondiÃ§Ãµes para notificaÃ§Ãµes:
// - Novo FVG de Alta (ğŸŸ¢)
// - Novo FVG de Baixa (ğŸ”´)
// - RSI cruzando 70 para cima (sobrecomprado)
// - RSI cruzando 30 para baixo (sobrevendido)

bool fvg_can_be_added = g_active_fvgs.size() < i_fvg_max_count
bool fvg_is_new = detectedFvg.birthTime > nz(g_prev_fvg_time, 0)
bool new_bull_fvg = i_fvg_enabled and barstate.isconfirmed and isBull and fvg_is_new and fvg_can_be_added and detectedFvg.isActive
bool new_bear_fvg = i_fvg_enabled and barstate.isconfirmed and isBear and fvg_is_new and fvg_can_be_added and detectedFvg.isActive

alertcondition(new_bull_fvg, title="Novo FVG de Alta", message="ğŸŸ¢ Novo FVG de Alta Detectado!")
alertcondition(new_bear_fvg, title="Novo FVG de Baixa", message="ğŸ”´ Novo FVG de Baixa Detectado!")
alertcondition(ta.crossover(rsi_current, 70.0), title="RSI Sobrecomprado (>70)", message="âš ï¸ RSI Cruzou 70 para cima")
alertcondition(ta.crossunder(rsi_current, 30.0), title="RSI Sobrevendido (<30)", message="âš ï¸ RSI Cruzou 30 para baixo")
 