//@version=6
indicator('ICT + FVG + RSI V1.2.1', shorttitle="ICT + FVG Pro 1.2.1", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500, max_bars_back=5000)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ METADADOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Nome:        ICT + FVG + RSI
// VersÃ£o:      1.2.1
// Atualizado:  2026-02-15
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“œ CHANGELOG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V1.2.1 (2026-02-14)
//    - Anti-Repaint: Monitor usa barstate.ishistory em vez de barstate.islast
//    - Bug Fix: RSI fallback nz() removido â€” evita mistura de dados entre TFs
//    - Limpeza: helper.name (cÃ³digo morto) removido de todos os mÃ©todos
//    - ManutenÃ§Ã£o: Constantes SEC_1H, SEC_4H, SEC_1D extraÃ­das
//
// V1.2.0 (2026-02-12)
//    - Bug Fix: request.security desenrolado do loop (5 chamadas explÃ­citas)
//    - Bug Fix: DayofWeek corrigido (usa constantes dayofweek.monday etc.)
//    - Bug Fix: str.tonumber substituÃ­do por timeframe.in_seconds no Monitor
//    - Anti-Repaint: Monitor agora exige barstate.isconfirmed para criar candle
//    - Anti-Repaint: MitigaÃ§Ã£o/expiraÃ§Ã£o FVG apenas em barstate.isconfirmed
//    - Performance: var adicionado a Settings, Helper e color_transparent
//    - Robustez: ValidTimeframe usa modulo (n2 % n1 == 0)
//    - Robustez: Debug table protegido contra NaN (nz/na checks)
//
// V1.1.8 (2025-12-20)
//    - Robustez: ProteÃ§Ã£o contra divisÃ£o por zero no mÃ©todo isExpired
//    - Robustez: Bounds checking e fallback para dados RSI invÃ¡lidos
//    - Robustez: Tabela RSI recria automaticamente ao mudar colunas
//    - Extensibilidade: ATR Period agora Ã© configurÃ¡vel via input
//    - Extensibilidade: Fuso horÃ¡rio configurÃ¡vel (5 opÃ§Ãµes)
//    - Extensibilidade: Timeframes da tabela RSI agora sÃ£o dinÃ¢micos

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”¢ CONSTANTES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const int MAX_TABLE_ROWS = 7
const int MAX_ITER_PER_BAR = 20
const int MAX_REMOVALS = 10
const int MS_PER_SECOND = 1000
const int SEC_1H  = 3600
const int SEC_4H  = 14400
const int SEC_1D  = 86400

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¦ TYPES
//    DefiniÃ§Ãµes de User-Defined Types (UDTs) usadas em todo o indicador.
//    Cada type encapsula dados e referÃªncias visuais para um domÃ­nio especÃ­fico.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Candle â€” representa um candle de higher timeframe (HTF) desenhado como overlay.
// Armazena dados OHLC, Ã­ndices de barra, e referÃªncias aos objetos grÃ¡ficos (box/line/label).
type Candle
    float o              // PreÃ§o de abertura (Open)
    float c              // PreÃ§o de fechamento (Close) â€” atualizado em tempo real
    float h              // PreÃ§o mÃ¡ximo (High) â€” atualizado em tempo real
    float l              // PreÃ§o mÃ­nimo (Low) â€” atualizado em tempo real
    int o_time           // Timestamp (ms) da abertura do candle HTF
    int o_idx            // bar_index da barra onde o candle HTF abriu
    int c_idx            // bar_index da barra mais recente (close atualizado)
    int h_idx            // bar_index da barra onde ocorreu a mÃ¡xima
    int l_idx            // bar_index da barra onde ocorreu a mÃ­nima
    string dow           // RÃ³tulo do dia/hora (ex: 'Seg', '14', 'Sem 7')
    box body             // Objeto box que desenha o corpo do candle
    line wick_up         // Linha do pavio superior (high â†’ max(o,c))
    line wick_down       // Linha do pavio inferior (min(o,c) â†’ low)
    label dow_label      // Label que exibe o dia da semana acima do candle

// Trace â€” linhas horizontais que conectam o preÃ§o atual atÃ© os candles HTF.
// Cada campo guarda a referÃªncia da line e do label correspondente ao nÃ­vel OHLC.
type Trace
    line o               // Linha de traÃ§o do preÃ§o Open
    line c               // Linha de traÃ§o do preÃ§o Close
    line h               // Linha de traÃ§o do preÃ§o High
    line l               // Linha de traÃ§o do preÃ§o Low
    label o_l            // Label com valor numÃ©rico do Open
    label c_l            // Label com valor numÃ©rico do Close
    label h_l            // Label com valor numÃ©rico do High
    label l_l            // Label com valor numÃ©rico do Low

// Imbalance â€” representa um FVG ou Volume Imbalance detectado DENTRO dos candles HTF.
// Usado pelo mÃ©todo FindImbalance para desenhar caixas entre candles adjacentes.
type Imbalance
    box b                // Objeto box que desenha o desequilÃ­brio visualmente
    int idx              // bar_index do candle mais recente quando o imbalance foi detectado
    int arr_i1           // Ãndice do primeiro candle no array candles (perna 1)
    int arr_i2           // Ãndice do segundo candle no array candles (perna 2 ou 3)

// CandleSettings â€” configuraÃ§Ãµes individuais para cada slot de timeframe HTF (1-6).
type CandleSettings
    bool show            // Se este HTF estÃ¡ ativo/visÃ­vel
    string htf           // CÃ³digo do timeframe (ex: '5', '15', '60', '1D')
    int max_display      // Limite mÃ¡ximo de candles renderizados para este slot

// Settings â€” configuraÃ§Ãµes globais do indicador (cores, tamanhos, comportamentos).
// Instanciado uma Ãºnica vez com `var` e preenchido na seÃ§Ã£o de INPUTS.
type Settings
    // --- Gerais ---
    int max_sets             // Limite mÃ¡ximo de grupos HTF exibidos simultaneamente
    // --- Cores dos candles HTF ---
    color bull_body          // Cor do corpo de candles de alta
    color bull_border        // Cor da borda de candles de alta
    color bull_wick          // Cor do pavio de candles de alta
    color bear_body          // Cor do corpo de candles de baixa
    color bear_border        // Cor da borda de candles de baixa
    color bear_wick          // Cor do pavio de candles de baixa
    // --- Layout ---
    int offset               // DistÃ¢ncia (em barras) entre grÃ¡fico atual e HTF candles
    int buffer               // EspaÃ§amento entre candles dentro do mesmo grupo HTF
    int htf_buffer           // EspaÃ§amento entre grupos de timeframes diferentes
    int width                // Largura visual do candle HTF (jÃ¡ multiplicado por 2)
    // --- Labels e Timer ---
    bool daily_name          // Exibir nome do dia da semana em candles diÃ¡rios
    bool trace_show          // Ativar trace lines (OHLC â†’ HTF candles)
    color trace_o_color      // Cor da trace line Open
    string trace_o_style     // Estilo da trace line Open ('â¯â¯â¯', '----', 'Â·Â·Â·Â·')
    int trace_o_size         // Espessura da trace line Open
    color trace_c_color      // Cor da trace line Close
    string trace_c_style     // Estilo da trace line Close
    int trace_c_size         // Espessura da trace line Close
    color trace_h_color      // Cor da trace line High
    string trace_h_style     // Estilo da trace line High
    int trace_h_size         // Espessura da trace line High
    color trace_l_color      // Cor da trace line Low
    string trace_l_style     // Estilo da trace line Low
    int trace_l_size         // Espessura da trace line Low
    string trace_anchor      // 'First Timeframe' ou 'Last Timeframe' â€” qual grupo recebe traces
    bool label_show          // Exibir labels de preÃ§o OHLC nas traces
    color label_color        // Cor do texto dos labels de preÃ§o
    string label_size        // Tamanho do texto dos labels de preÃ§o
    string label_position    // PosiÃ§Ã£o dos labels HTF: 'Top', 'Bottom', 'Both'
    string label_alignment   // 'Align' (fixo) ou 'Follow Candles' (dinÃ¢mico)
    // --- FVG/VI MTF (dentro dos candles HTF) ---
    bool fvg_show            // Detectar FVGs entre candles HTF
    color fvg_color          // Cor das caixas FVG MTF
    bool vi_show             // Detectar Volume Imbalances entre candles HTF
    color vi_color           // Cor das caixas VI MTF
    // --- Labels HTF ---
    bool htf_label_show      // Exibir nome do timeframe acima/abaixo dos candles
    color htf_label_color    // Cor do label do nome HTF
    string htf_label_size    // Tamanho do label do nome HTF
    bool htf_timer_show      // Exibir timer de contagem regressiva
    color htf_timer_color    // Cor do timer
    string htf_timer_size    // Tamanho do timer
    color dow_color          // Cor do label do dia da semana
    string dow_size          // Tamanho do label do dia da semana

// CandleSet â€” agrupa todos os dados de um slot de timeframe HTF.
// Cada slot (htf1â€¦htf6) possui seu prÃ³prio CandleSet com candles, imbalances e labels.
type CandleSet
    array<Candle> candles          // Array de candles HTF renderizados (FIFO)
    array<Imbalance> imbalances    // Array de FVGs/VIs detectados entre os candles
    CandleSettings settings        // ConfiguraÃ§Ãµes especÃ­ficas deste slot (show, htf, max)
    label tfNameTop                // Label do nome do TF (posiÃ§Ã£o superior)
    label tfNameBottom             // Label do nome do TF (posiÃ§Ã£o inferior)
    label tfTimerTop               // Label do timer countdown (posiÃ§Ã£o superior)
    label tfTimerBottom            // Label do timer countdown (posiÃ§Ã£o inferior)


// FVG â€” Fair Value Gap detectado no grÃ¡fico principal (nÃ£o Ã© o FVG MTF dos candles HTF).
// Ciclo de vida: criaÃ§Ã£o (f_fvg_detect) â†’ desenho (draw) â†’ mitigaÃ§Ã£o/expiraÃ§Ã£o (remove).
type FVG
    float top            // Topo do gap (low da barra central para bull, low[2] para bear)
    float bottom         // Base do gap (high[2] para bull, high da barra central para bear)
    bool isBull          // true = FVG de alta (gap acima), false = FVG de baixa (gap abaixo)
    int birthTime        // Timestamp (ms) da barra onde o gap se formou (time[2])
    box boxObj           // Objeto box desenhado no grÃ¡fico (xloc.bar_time)
    line mitigatedLine   // Reservado para linha de mitigaÃ§Ã£o (nÃ£o utilizado atualmente)
    bool isActive        // true enquanto o FVG nÃ£o foi mitigado nem expirou

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ INPUTS
//    ParÃ¢metros configurÃ¡veis pelo usuÃ¡rio via painel de settings do TradingView.
//    Organizados em grupos: HTF Candles, Styling, Labels, Imbalances,
//    Trace Lines, EMA, RSI, Tabela RSI e FVG GrÃ¡fico.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// InstÃ¢ncias das configuraÃ§Ãµes â€” alocadas com `var` para persistÃªncia entre barras.
// [FIX v1.2.0] var adicionado â€” Settings alocados uma Ãºnica vez
var Settings settings = Settings.new()
var CandleSettings SettingsHTF1 = CandleSettings.new()  // Config slot HTF 1
var CandleSettings SettingsHTF2 = CandleSettings.new()  // Config slot HTF 2
var CandleSettings SettingsHTF3 = CandleSettings.new()  // Config slot HTF 3
var CandleSettings SettingsHTF4 = CandleSettings.new()  // Config slot HTF 4
var CandleSettings SettingsHTF5 = CandleSettings.new()  // Config slot HTF 5 (Daily)
var CandleSettings SettingsHTF6 = CandleSettings.new()  // Config slot HTF 6 (Weekly)

string group_htf = "ğŸ“Š HTF Candles  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_style = "ğŸ¨ Styling  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_label = "ğŸ·ï¸ Labels  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_imbalance = "âš–ï¸ MTF Imbalances  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_trace = "ğŸ“ Trace Lines  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_ema = "ğŸ“ˆ EMA  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_rsi = "ğŸ“‰ RSI  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_table = "ğŸ“‹ Tabela RSI  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
string group_fvg = "ğŸ¯ FVG GrÃ¡fico  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

SettingsHTF1.show := input.bool(true, 'HTF 1', inline='htf1', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 1')
htf_1 = input.timeframe('5', '', inline='htf1', group=group_htf)
SettingsHTF1.htf := htf_1
SettingsHTF1.max_display := input.int(10, '', inline='htf1', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF2.show := input.bool(true, 'HTF 2', inline='htf2', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 2')
htf_2 = input.timeframe('15', '', inline='htf2', group=group_htf)
SettingsHTF2.htf := htf_2
SettingsHTF2.max_display := input.int(8, '', inline='htf2', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF3.show := input.bool(true, 'HTF 3', inline='htf3', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 3')
htf_3 = input.timeframe('60', '', inline='htf3', group=group_htf)
SettingsHTF3.htf := htf_3
SettingsHTF3.max_display := input.int(6, '', inline='htf3', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF4.show := input.bool(true, 'HTF 4', inline='htf4', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 4')
htf_4 = input.timeframe('240', '', inline='htf4', group=group_htf)
SettingsHTF4.htf := htf_4
SettingsHTF4.max_display := input.int(5, '', inline='htf4', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF5.show := input.bool(true, 'HTF 5', inline='htf5', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 5 (Daily)')
htf_5 = input.timeframe('1D', '', inline='htf5', group=group_htf)
SettingsHTF5.htf := htf_5
SettingsHTF5.max_display := input.int(5, '', inline='htf5', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

SettingsHTF6.show := input.bool(true, 'HTF 6', inline='htf6', group=group_htf, tooltip='Ativa/desativa exibiÃ§Ã£o do timeframe 6 (Weekly)')
htf_6 = input.timeframe('1W', '', inline='htf6', group=group_htf)
SettingsHTF6.htf := htf_6
SettingsHTF6.max_display := input.int(3, '', inline='htf6', group=group_htf, tooltip='Quantidade mÃ¡xima de candles a exibir')

settings.max_sets := input.int(3, 'Limite HTFs', minval=1, maxval=6, group=group_htf, tooltip='NÃºmero mÃ¡ximo de grupos HTF a exibir simultaneamente (1-6)')
i_timezone = input.string('America/Sao_Paulo', 'Fuso HorÃ¡rio', options=['America/Sao_Paulo', 'America/New_York', 'Europe/London', 'Asia/Tokyo', 'UTC'], group=group_htf, tooltip='Fuso horÃ¡rio para cÃ¡lculo de datas e horÃ¡rios dos candles HTF')
i_auto_daily = input.bool(true, 'Daily Auto (>=1H)', group=group_htf, tooltip='Mostra MTF Daily apenas quando grÃ¡fico estÃ¡ em 1H ou acima')
i_auto_weekly = input.bool(true, 'Weekly Auto (>=4H)', group=group_htf, tooltip='Mostra MTF Weekly apenas quando grÃ¡fico estÃ¡ em 4H ou acima')

bool showDailyAuto = i_auto_daily and timeframe.in_seconds() >= SEC_1H
if i_auto_daily
    SettingsHTF5.show := showDailyAuto

bool showWeeklyAuto = i_auto_weekly and timeframe.in_seconds() >= SEC_4H
if i_auto_weekly
    SettingsHTF6.show := showWeeklyAuto

settings.bull_body := input.color(color.new(#089981, 70),'Body Bull/Bear', inline='body', group=group_style, tooltip='Cor do corpo dos candles de alta (esquerda) e baixa (direita)')
settings.bear_body := input.color(color.new(#f23645, 70), '', inline='body', group=group_style)
settings.bull_border := input.color(color.new(#000000,70), 'Border', inline='borders', group=group_style, tooltip='Cor da borda dos candles de alta e baixa')
settings.bear_border := input.color(color.new(#000000,70), '', inline='borders', group=group_style)
settings.bull_wick := input.color(color.new(color.black, 70), 'Wick', inline='wick', group=group_style, tooltip='Cor dos pavios dos candles de alta e baixa')
settings.bear_wick := input.color(color.new(color.black, 70), '', inline='wick', group=group_style)
settings.offset := input.int(30, 'Offset', minval=1, group=group_style, tooltip='DistÃ¢ncia horizontal entre o Ãºltimo candle do grÃ¡fico e os HTF candles')
settings.buffer := input.int(1, 'Buffer', minval=1, maxval=4, group=group_style, tooltip='EspaÃ§amento entre candles individuais dentro de um grupo HTF')
settings.htf_buffer := input.int(5, 'HTF Buffer', minval=1, maxval=10, group=group_style, tooltip='EspaÃ§amento entre grupos de diferentes timeframes')
settings.width := input.int(1, 'Width', minval=1, maxval=4, group=group_style, tooltip='Largura visual dos candles HTF (multiplicado por 2)') * 2

settings.htf_label_show := input.bool(true, 'HTF Label', inline='HTFlabel', group=group_label, tooltip='Exibe o nome do timeframe acima/abaixo dos candles')
settings.htf_label_color := input.color(color.new(#000000, 0), '', inline='HTFlabel', group=group_label)
settings.htf_label_size := input.string(size.normal, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='HTFlabel', group=group_label)
settings.label_position := input.string("Top", 'Position', options=['Both', 'Top', 'Bottom'], group=group_label, tooltip='PosiÃ§Ã£o do label: Topo, Base ou Ambos')
settings.label_alignment := input.string("Follow Candles", "Alignment", options=['Align', 'Follow Candles'], group=group_label, tooltip='Align: labels alinhados | Follow: labels seguem posiÃ§Ã£o dos candles')
settings.htf_timer_show := input.bool(true, 'Timer', inline='timer', group=group_label, tooltip='Exibe contagem regressiva atÃ© o fechamento do candle HTF')
settings.htf_timer_color := input.color(color.new(color.black, 10), '', inline='timer', group=group_label)
settings.htf_timer_size := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='timer', group=group_label)
settings.daily_name := input.bool(true, 'DOW Label', inline='dow', group=group_label, tooltip='Exibe nome do dia da semana (Seg, Ter...) para candles diÃ¡rios')
settings.dow_color := input.color(color.black, '', inline='dow', group=group_label)
settings.dow_size := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='dow', group=group_label)

settings.fvg_show := input.bool(true, 'FVG MTF', inline='fvg', group=group_imbalance, tooltip='Detecta e exibe Fair Value Gaps nos candles HTF')
settings.fvg_color := input.color(color.rgb(120, 123, 134, 85),'', inline='fvg', group=group_imbalance)
settings.vi_show := input.bool(false, 'VI MTF', inline='vi', group=group_imbalance, tooltip='Detecta e exibe Volume Imbalances nos candles HTF')
settings.vi_color := input.color(color.new(color.red, 50), '', inline='vi', group=group_imbalance)

settings.trace_show := input.bool(false, 'Trace Lines', group=group_trace, tooltip='Desenha linhas conectando OHLC do candle atual atÃ© os HTF candles')
settings.trace_o_color := input.color(color.new(color.gray, 50), 'Open', inline='1', group=group_trace, tooltip='Linha do preÃ§o de abertura: cor, estilo e espessura')
settings.trace_o_style := input.string('Â·Â·Â·Â·', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='1', group=group_trace)
settings.trace_o_size := input.int(1, '', options=[1, 2, 3, 4], inline='1', group=group_trace)
settings.trace_c_color := input.color(color.new(color.gray, 50), 'Close', inline='2', group=group_trace, tooltip='Linha do preÃ§o de fechamento: cor, estilo e espessura')
settings.trace_c_style := input.string('Â·Â·Â·Â·', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='2', group=group_trace)
settings.trace_c_size := input.int(1, '', options=[1, 2, 3, 4], inline='2', group=group_trace)
settings.trace_h_color := input.color(color.new(color.gray, 50), 'High', inline='3', group=group_trace, tooltip='Linha da mÃ¡xima: cor, estilo e espessura')
settings.trace_h_style := input.string('â¯â¯â¯', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='3', group=group_trace)
settings.trace_h_size := input.int(1, '', options=[1, 2, 3, 4], inline='3', group=group_trace)
settings.trace_l_color := input.color(color.new(color.gray, 50), 'Low', inline='4', group=group_trace, tooltip='Linha da mÃ­nima: cor, estilo e espessura')
settings.trace_l_style := input.string('â¯â¯â¯', '', options=['â¯â¯â¯', '----', 'Â·Â·Â·Â·'], inline='4', group=group_trace)
settings.trace_l_size := input.int(1, '', options=[1, 2, 3, 4], inline='4', group=group_trace)
settings.trace_anchor := input.string('First Timeframe', 'Anchor', options=['First Timeframe', 'Last Timeframe'], group=group_trace, tooltip='Define qual grupo HTF recebe as trace lines')
settings.label_show := input.bool(false, 'Price Labels', inline='label', group=group_trace, tooltip='Exibe labels com os preÃ§os OHLC nas extremidades das linhas')
settings.label_color := input.color(color.new(color.black, 10), '', inline='label', group=group_trace)
settings.label_size := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='label', group=group_trace)

i_showEMA = input.bool(false, 'âš¡ Ativar EMA', group=group_ema, tooltip='Ativa a MÃ©dia MÃ³vel Exponencial no grÃ¡fico')
i_emaLength = input.int(26, 'PerÃ­odo', minval=1, maxval=500, group=group_ema, tooltip='NÃºmero de barras para cÃ¡lculo da EMA (padrÃ£o: 26)')
i_emaColor = input.color(#4a4a4acc, 'Cor', group=group_ema, tooltip='Cor da linha EMA')
i_emaWidth = input.int(1, 'Espessura', minval=1, maxval=5, group=group_ema, tooltip='Espessura da linha EMA')
i_emaSource = input.source(close, 'Fonte', group=group_ema, tooltip='Fonte de dados para cÃ¡lculo (close, open, high, low, hl2, etc.)')

i_rsi_length = input.int(14, 'PerÃ­odo RSI', minval=2, maxval=200, group=group_rsi, tooltip='PerÃ­odo para cÃ¡lculo do RSI (padrÃ£o: 14)')
i_show_rsi_25 = input.bool(false, 'Exibir NÃ­vel 25', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 25')
i_show_rsi_30 = input.bool(false, 'Exibir NÃ­vel 30', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 30 (sobrevendido)')
i_show_rsi_50 = input.bool(false, 'Exibir NÃ­vel 50', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 50 (neutro)')
i_show_rsi_70 = input.bool(false, 'Exibir NÃ­vel 70', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 70 (sobrecomprado)')
i_show_rsi_75 = input.bool(false, 'Exibir NÃ­vel 75', group=group_rsi, tooltip='Plota linha horizontal no preÃ§o correspondente a RSI = 75')
i_show_rsi_custom = input.bool(false, 'â­ Exibir RSI Customizado', group=group_rsi, tooltip='Plota linha horizontal para um nÃ­vel RSI personalizado')
i_rsi_custom_level = input.float(40, 'NÃ­vel RSI Customizado', minval=1, maxval=99, step=1, group=group_rsi, tooltip='Define o nÃ­vel RSI desejado para a linha customizada (1-99)')
i_rsi_custom_color = input.color(color.new(#ff9800, 0), 'Cor RSI Customizado', group=group_rsi, tooltip='Cor da linha RSI customizada')
i_rsi_max_deviation = input.float(0.30, 'Desvio MÃ¡ximo (%)', minval=0.10, maxval=1.00, step=0.05, group=group_rsi, tooltip='Limite mÃ¡ximo de variaÃ§Ã£o de preÃ§o para cÃ¡lculos RSI (evita valores extremos)')

i_table_show = input.bool(true, 'Exibir Tabela', group=group_table, tooltip='Ativa a tabela multi-timeframe com valores RSI e preÃ§os-alvo')
i_rsi_tf1 = input.timeframe('5', 'TF 1', inline='rsi_tf1', group=group_table, tooltip='Timeframe 1 da tabela RSI')
i_rsi_tf1_name = input.string('5m', '', inline='rsi_tf1', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf2 = input.timeframe('15', 'TF 2', inline='rsi_tf2', group=group_table, tooltip='Timeframe 2 da tabela RSI')
i_rsi_tf2_name = input.string('15m', '', inline='rsi_tf2', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf3 = input.timeframe('60', 'TF 3', inline='rsi_tf3', group=group_table, tooltip='Timeframe 3 da tabela RSI')
i_rsi_tf3_name = input.string('1h', '', inline='rsi_tf3', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf4 = input.timeframe('240', 'TF 4', inline='rsi_tf4', group=group_table, tooltip='Timeframe 4 da tabela RSI')
i_rsi_tf4_name = input.string('4h', '', inline='rsi_tf4', group=group_table, tooltip='Nome exibido na tabela')
i_rsi_tf5 = input.timeframe('D', 'TF 5', inline='rsi_tf5', group=group_table, tooltip='Timeframe 5 da tabela RSI')
i_rsi_tf5_name = input.string('1D', '', inline='rsi_tf5', group=group_table, tooltip='Nome exibido na tabela')
i_table_show_col1 = input.bool(false, 'Exibir Coluna 1', inline='col1', group=group_table, tooltip='Ativa/desativa a coluna de preÃ§o para o nÃ­vel RSI 1')
i_table_col1_level = input.float(30, '', minval=1, maxval=99, step=1, inline='col1', group=group_table, tooltip='NÃ­vel RSI para calcular preÃ§o')
i_table_show_col2 = input.bool(false, 'Exibir Coluna 2', inline='col2', group=group_table, tooltip='Ativa/desativa a coluna de preÃ§o para o nÃ­vel RSI 2')
i_table_col2_level = input.float(70, '', minval=1, maxval=99, step=1, inline='col2', group=group_table, tooltip='NÃ­vel RSI para calcular preÃ§o')
i_table_position = input.string('top_right', 'PosiÃ§Ã£o', options=['top_right', 'top_left', 'bottom_right', 'bottom_left'], group=group_table, tooltip='PosiÃ§Ã£o da tabela RSI no grÃ¡fico')

i_fvg_enabled = input.bool(true, 'âš¡ Ativar FVG', group=group_fvg, tooltip='Ativa detecÃ§Ã£o e exibiÃ§Ã£o de Fair Value Gaps no grÃ¡fico principal')
i_fvg_auto_threshold = input.bool(false, 'Threshold ATR Auto', group=group_fvg, tooltip='Quando ativo, usa ATR para calcular automaticamente o limiar mÃ­nimo de FVG')
i_fvg_threshold = input.float(0.3, 'Limiar (%)', minval=0.01, maxval=10, step=0.05, group=group_fvg, tooltip='Tamanho mÃ­nimo do gap em % para ser considerado FVG')
i_fvg_adaptive_tf = input.bool(true, 'Adaptativo TF', group=group_fvg, tooltip='Multiplica o limiar baseado no timeframe')
i_fvg_max_multiplier = input.float(5.0, 'Mult. MÃ¡ximo', minval=1.0, maxval=20.0, step=0.5, group=group_fvg, tooltip='Limite mÃ¡ximo do multiplicador adaptativo por timeframe')
i_fvg_timeframe = input.timeframe('', 'Timeframe', group=group_fvg, tooltip='Timeframe para detecÃ§Ã£o de FVG (vazio = TF atual)')
i_fvg_extend_bars = input.int(15, 'ExtensÃ£o', minval=5, maxval=200, group=group_fvg, tooltip='Quantas barras a caixa FVG se estende para a direita')
i_fvg_max_count = input.int(8, 'MÃ¡ximo FVGs', minval=1, maxval=50, group=group_fvg, tooltip='NÃºmero mÃ¡ximo de FVGs ativos simultaneamente')
i_fvg_max_age = input.int(300, 'Idade MÃ¡x', minval=50, maxval=1000, group=group_fvg, tooltip='Remove FVGs nÃ£o mitigados apÃ³s esta quantidade de barras')
i_fvg_bull_color = input.color(color.new(#089981, 85), 'Cor Alta', group=group_fvg, tooltip='Cor das caixas FVG bullish')
i_fvg_bear_color = input.color(color.new(#f23645, 85), 'Cor Baixa', group=group_fvg, tooltip='Cor das caixas FVG bearish')
i_fvg_mitigation_type = input.string('50% (Meio)', 'MitigaÃ§Ã£o', options=['50% (Meio)', '100% (Completo)', '25% (Conservador)'], group=group_fvg, tooltip='Define quando um FVG Ã© considerado mitigado')
i_fvg_debug = input.bool(false, 'Debug Mode', group=group_fvg, tooltip='Exibe tabela de debug com informaÃ§Ãµes tÃ©cnicas sobre os FVGs')
i_atr_period = input.int(14, 'ATR PerÃ­odo', minval=5, maxval=50, group=group_fvg, tooltip='PerÃ­odo do ATR usado no threshold automÃ¡tico de FVG')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ VARIÃVEIS GLOBAIS
//    Estado persistente do indicador, alocado via `var` (mantido entre barras).
//    Dividido em: arrays de candles/imbalances, CandleSets (slots HTF),
//    estado RSI (caches, arrays, tabela) e estado FVG (lista ativa, debug).
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// --- Arrays de candles HTF (um por slot, FIFO: Ã­ndice 0 = mais recente) ---
var array<Candle> candles_1 = array.new<Candle>(0)
var array<Candle> candles_2 = array.new<Candle>(0)
var array<Candle> candles_3 = array.new<Candle>(0)
var array<Candle> candles_4 = array.new<Candle>(0)
var array<Candle> candles_5 = array.new<Candle>(0)
var array<Candle> candles_6 = array.new<Candle>(0)


// --- Arrays de imbalances FVG/VI MTF (um por slot HTF) ---
var array<Imbalance> imbalances_1 = array.new<Imbalance>()
var array<Imbalance> imbalances_2 = array.new<Imbalance>()
var array<Imbalance> imbalances_3 = array.new<Imbalance>()
var array<Imbalance> imbalances_4 = array.new<Imbalance>()
var array<Imbalance> imbalances_5 = array.new<Imbalance>()
var array<Imbalance> imbalances_6 = array.new<Imbalance>()


// --- InstÃ¢ncias CandleSet: ligam arrays aos slots HTF e armazenam labels ---
var CandleSet htf1 = CandleSet.new()  // Slot HTF 1 (ex: 5m)
htf1.settings := SettingsHTF1
htf1.candles := candles_1
htf1.imbalances := imbalances_1

var CandleSet htf2 = CandleSet.new()  // Slot HTF 2 (ex: 15m)
htf2.settings := SettingsHTF2
htf2.candles := candles_2
htf2.imbalances := imbalances_2

var CandleSet htf3 = CandleSet.new()  // Slot HTF 3 (ex: 1h)
htf3.settings := SettingsHTF3
htf3.candles := candles_3
htf3.imbalances := imbalances_3

var CandleSet htf4 = CandleSet.new()  // Slot HTF 4 (ex: 4h)
htf4.settings := SettingsHTF4
htf4.candles := candles_4
htf4.imbalances := imbalances_4

var CandleSet htf5 = CandleSet.new()  // Slot HTF 5 (ex: 1D)
htf5.settings := SettingsHTF5
htf5.candles := candles_5
htf5.imbalances := imbalances_5

var CandleSet htf6 = CandleSet.new()  // Slot HTF 6 (ex: 1W)
htf6.settings := SettingsHTF6
htf6.candles := candles_6
htf6.imbalances := imbalances_6


// --- Objetos Ãºnicos globais ---
// [FIX v1.2.1] Helper removido â€” mÃ©todos convertidos em funÃ§Ãµes puras
var Trace trace = Trace.new()           // InstÃ¢ncia Ãºnica das trace lines OHLC
// [FIX v1.2.0] var adicionado
var color color_transparent = #ffffff00 // Cor transparente reutilizÃ¡vel (evita recriaÃ§Ã£o)


// --- Estado RSI (caches de preÃ§o e componentes por timeframe) ---
float RSI_ALPHA = 1.0 / i_rsi_length                    // Fator de suavizaÃ§Ã£o EMA do RSI (1/perÃ­odo)
var array<string> g_rsi_tfs = array.from(i_rsi_tf1, i_rsi_tf2, i_rsi_tf3, i_rsi_tf4, i_rsi_tf5)            // TFs configurados
var array<string> g_rsi_tfs_display = array.from(i_rsi_tf1_name, i_rsi_tf2_name, i_rsi_tf3_name, i_rsi_tf4_name, i_rsi_tf5_name)  // Nomes exibidos na tabela
var float[] g_rsi_values = array.new_float(5, na)        // RSI atual de cada TF (Ã­ndice 0â€¦4)
var float[] g_rsi_close  = array.new_float(5, na)        // Close de cada TF
var float[] g_rsi_auc    = array.new_float(5, na)        // EMA dos ganhos (avg up change)
var float[] g_rsi_adc    = array.new_float(5, na)        // EMA das perdas (avg down change)
var float g_cached_rsi25 = na         // PreÃ§o-alvo cacheado para RSI = 25
var float g_cached_rsi30 = na         // PreÃ§o-alvo cacheado para RSI = 30
var float g_cached_rsi50 = na         // PreÃ§o-alvo cacheado para RSI = 50
var float g_cached_rsi70 = na         // PreÃ§o-alvo cacheado para RSI = 70
var float g_cached_rsi75 = na         // PreÃ§o-alvo cacheado para RSI = 75
var float g_cached_rsi_custom = na    // PreÃ§o-alvo cacheado para nÃ­vel customizado
var int g_last_calc_bar = -1          // bar_index da Ãºltima atualizaÃ§Ã£o do cache RSI
var table g_rsi_table = na            // ReferÃªncia da tabela RSI MTF
var int g_prev_col_config = 0         // ConfiguraÃ§Ã£o anterior de colunas (detecta mudanÃ§a)

// --- Estado FVG GrÃ¡fico (lista ativa, controle de duplicatas, debug) ---
var array<FVG> g_active_fvgs = array.new<FVG>()  // FVGs ativos no grÃ¡fico principal (FIFO)
var int g_prev_fvg_time = 0           // Timestamp do Ãºltimo FVG ANTES de nova adiÃ§Ã£o (anti-duplicata)
var int g_last_fvg_time = 0           // Timestamp do FVG mais recente adicionado
var array<int> g_fvg_to_remove = array.new<int>()  // Buffer de Ã­ndices para remoÃ§Ã£o em batch
var int g_tf_seconds = 0              // DuraÃ§Ã£o em segundos do TF de detecÃ§Ã£o FVG
var table g_debug_table = na          // ReferÃªncia da tabela de debug FVG

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡Ã•ES AUXILIARES - ICT
//    FunÃ§Ãµes puras que nÃ£o modificam estado global. Usadas na renderizaÃ§Ã£o
//    e configuraÃ§Ã£o dos candles HTF, trace lines e labels.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @description  Converte string visual de estilo de linha para constante Pine.
// @param style  String de estilo ('â¯â¯â¯', '----', 'Â·Â·Â·Â·')
// @returns      Constante line.style_* correspondente
f_line_style(string style) =>
    switch style
        '----' => line.style_dashed
        'Â·Â·Â·Â·' => line.style_dotted
        => line.style_solid

// @description  Converte Ã­ndice numÃ©rico do dia da semana para abreviaÃ§Ã£o em portuguÃªs.
// @param index  Constante dayofweek.* (1=Dom, 2=Seg, â€¦ 7=SÃ¡b)
// @returns      String abreviada ('Seg', 'Ter', â€¦) ou '' se na/invÃ¡lido
// [FIX v1.2.0] DayofWeek corrigido â€” usa constantes Pine + default robusto
f_day_of_week(int index) =>
    if na(index)
        ''
    else
        switch index
            dayofweek.monday    => 'Seg'
            dayofweek.tuesday   => 'Ter'
            dayofweek.wednesday => 'Qua'
            dayofweek.thursday  => 'Qui'
            dayofweek.friday    => 'Sex'
            dayofweek.saturday  => 'SÃ¡b'
            dayofweek.sunday    => 'Dom'
            => ''

// @description  Verifica se um timeframe HTF Ã© compatÃ­vel com o TF atual do grÃ¡fico.
//               Para TFs >= DiÃ¡rio: basta ser maior que o atual.
//               Para intraday: exige que HTF seja mÃºltiplo exato do TF atual.
// @param HTF    CÃ³digo do timeframe a validar (ex: '15', '60', '1D')
// @returns      true se o HTF pode ser renderizado corretamente
// [FIX v1.2.0] ValidTimeframe usa modulo para precisÃ£o
f_valid_timeframe(string HTF) =>
    if timeframe.in_seconds(HTF) >= timeframe.in_seconds('D') and timeframe.in_seconds(HTF) > timeframe.in_seconds()
        true
    else
        n1 = timeframe.in_seconds()
        n2 = timeframe.in_seconds(HTF)
        n1 < n2 and n2 % n1 == 0

// @description  Calcula o tempo restante atÃ© o fechamento do candle HTF.
//               Usa cÃ¡lculo matemÃ¡tico puro (openTime + duraÃ§Ã£o - timenow)
//               para evitar request.security em bloco condicional.
// @param HTF       CÃ³digo do timeframe (para calcular a duraÃ§Ã£o)
// @param openTime  Timestamp (ms) da abertura do candle HTF atual
// @returns         String formatada ('MM:SS', 'HH:MM:SS', 'ND HH:MM:SS' ou '--:--')
f_remaining_time(string HTF, int openTime) =>
    if barstate.islast
        // [FIX] CÃ¡lculo matemÃ¡tico (evita request.security em bloco condicional)
        int duration = timeframe.in_seconds(HTF) * 1000
        int closeTime = openTime + duration
        timeRemaining = math.max(0, (closeTime - timenow) / 1000)
        days = math.floor(timeRemaining / SEC_1D)
        hours = math.floor((timeRemaining - days * SEC_1D) / SEC_1H)
        minutes = math.floor((timeRemaining - days * SEC_1D - hours * SEC_1H) / 60)
        seconds = math.floor(timeRemaining - days * SEC_1D - hours * SEC_1H - minutes * 60)
        r = str.tostring(seconds, '00')
        if minutes > 0 or hours > 0 or days > 0
            r := str.tostring(minutes, '00') + ':' + r
        if hours > 0 or days > 0
            r := str.tostring(hours, '00') + ':' + r
        if days > 0
            r := str.tostring(days) + 'D ' + r
        r
    else
        '--:--'

// @description  Converte cÃ³digo de timeframe para formato de exibiÃ§Ã£o legÃ­vel.
// @param HTF    CÃ³digo do timeframe (ex: '5', '60', '1D')
// @returns      String formatada (ex: '5m', '1H', '1D')
f_htf_name(string HTF) =>
    seconds = timeframe.in_seconds(HTF)
    if seconds < 60
        str.tostring(seconds) + 's'
    else if seconds / 60 < 60
        str.tostring(seconds / 60) + 'm'
    else if seconds / 60 / 60 < 24
        str.tostring(seconds / 60 / 60) + 'H'
    else
        HTF

// @description  Conta quantos slots HTF estÃ£o ativos, limitado por settings.max_sets.
// @returns      NÃºmero de HTFs que serÃ£o renderizados (0 a settings.max_sets)
f_htf_enabled() =>
    int enabled = 0
    enabled += htf1.settings.show ? 1 : 0
    enabled += htf2.settings.show ? 1 : 0
    enabled += htf3.settings.show ? 1 : 0
    enabled += htf4.settings.show ? 1 : 0
    enabled += htf5.settings.show ? 1 : 0
    enabled += htf6.settings.show ? 1 : 0
    math.min(enabled, settings.max_sets)

// @description  Encontra o preÃ§o mÃ¡ximo (high) dentre todos os candles de um array.
// @param candles  Array de Candle a analisar
// @param h        Valor inicial de comparaÃ§Ã£o (acumulador)
// @returns        Maior high encontrado (ou h se array vazio)
f_candle_set_high(array<Candle> candles, float h) =>
    float _h = h
    if candles.size() > 0
        for i = 0 to candles.size() - 1
            if candles.get(i).h > _h
                _h := candles.get(i).h
    _h

// @description  Encontra o preÃ§o mÃ­nimo (low) dentre todos os candles de um array.
// @param candles  Array de Candle a analisar
// @param l        Valor inicial de comparaÃ§Ã£o (acumulador)
// @returns        Menor low encontrado (ou l se array vazio)
f_candle_set_low(array<Candle> candles, float l) =>
    float _l = l
    if candles.size() > 0
        for i = 0 to candles.size() - 1
            if candles.get(i).l < _l
                _l := candles.get(i).l
    _l

// @description  Encontra o high global entre todos os slots HTF ativos.
//               Itera os 6 slots respeitando show + valid + max_sets.
// @returns      Maior high de todos os candles HTF renderizados
f_candles_high() =>
    h = 0.0
    int cnt = 0
    int last = f_htf_enabled()
    if htf1.settings.show and f_valid_timeframe(htf1.settings.htf)
        h := f_candle_set_high(htf1.candles, h), cnt += 1
    if htf2.settings.show and f_valid_timeframe(htf2.settings.htf) and cnt < last
        h := f_candle_set_high(htf2.candles, h), cnt += 1
    if htf3.settings.show and f_valid_timeframe(htf3.settings.htf) and cnt < last
        h := f_candle_set_high(htf3.candles, h), cnt += 1
    if htf4.settings.show and f_valid_timeframe(htf4.settings.htf) and cnt < last
        h := f_candle_set_high(htf4.candles, h), cnt += 1
    if htf5.settings.show and f_valid_timeframe(htf5.settings.htf) and cnt < last
        h := f_candle_set_high(htf5.candles, h), cnt += 1
    if htf6.settings.show and f_valid_timeframe(htf6.settings.htf) and cnt < last
        h := f_candle_set_high(htf6.candles, h)
    h

// @description  Encontra o low global entre todos os slots HTF ativos.
// @param h      High global (usado como valor inicial do acumulador)
// @returns      Menor low de todos os candles HTF renderizados
f_candles_low(float h) =>
    l = h
    int cnt = 0
    int last = f_htf_enabled()
    if htf1.settings.show and f_valid_timeframe(htf1.settings.htf)
        l := f_candle_set_low(htf1.candles, l), cnt += 1
    if htf2.settings.show and f_valid_timeframe(htf2.settings.htf) and cnt < last
        l := f_candle_set_low(htf2.candles, l), cnt += 1
    if htf3.settings.show and f_valid_timeframe(htf3.settings.htf) and cnt < last
        l := f_candle_set_low(htf3.candles, l), cnt += 1
    if htf4.settings.show and f_valid_timeframe(htf4.settings.htf) and cnt < last
        l := f_candle_set_low(htf4.candles, l), cnt += 1
    if htf5.settings.show and f_valid_timeframe(htf5.settings.htf) and cnt < last
        l := f_candle_set_low(htf5.candles, l), cnt += 1
    if htf6.settings.show and f_valid_timeframe(htf6.settings.htf) and cnt < last
        l := f_candle_set_low(htf6.candles, l)
    l

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡Ã•ES RSI
//    CÃ¡lculo do RSI e preÃ§os-alvo reversos. O RSI Ã© decomposto em
//    componentes EMA (avg up / avg down change) para permitir cÃ¡lculo
//    inverso: "qual preÃ§o faria o RSI atingir N?".
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @description  Calcula comprimento EMA equivalente ao perÃ­odo RSI.
//               FÃ³rmula: max(1, 2 * rsi_length - 1). NecessÃ¡rio para
//               extraÃ§Ã£o dos componentes avg_up e avg_down via ta.ema.
// @returns      Comprimento inteiro da EMA
f_rsi_ema_length() => math.max(1, 2 * i_rsi_length - 1)

// @description  Retorna par [bgcolor, txt_color] baseado no valor RSI.
//               Escala: â‰¤ 20 (verde escuro) â†’ 45-55 (branco neutro) â†’ â‰¥ 80 (vermelho).
// @param r      Valor RSI (0-100) ou na
// @returns      [color fundo, color texto] para uso em table.cell
f_rsi_color(float r) =>
    switch
        na(r) => [color.new(#272727, 0), color.white]
        r < 20 => [color.new(#006400, 0), color.white]
        r < 30 => [color.new(#00A863, 20), color.white]
        r < 45 => [color.new(#ceecce, 5), color.rgb(0, 0, 0)]
        r <= 55 => [color.new(#ffffff, 0), color.rgb(0, 0, 0)]
        r < 70 => [color.new(#f7d1cf, 0), color.rgb(0, 0, 0)]
        r < 80 => [color.new(#c25e5e, 15), color.white]
        => [color.new(#b10000, 0), color.white]

// @description  Valida se os componentes RSI sÃ£o vÃ¡lidos para cÃ¡lculo de preÃ§o.
// @param c      Close do timeframe
// @param au     EMA dos ganhos (avg up change)
// @param ad     EMA das perdas (avg down change)
// @returns      true se todos os valores sÃ£o nÃ£o-na e positivos
f_rsi_is_valid(float c, float au, float ad) =>
    not na(c) and not na(au) and not na(ad) and c > 0 and au >= 0 and ad >= 0

// @description  CÃ¡lculo reverso do RSI: dado um RSI-alvo, calcula qual preÃ§o
//               o ativo precisaria atingir na prÃ³xima barra.
//               Usa a fÃ³rmula inversa do RSI Wilder com clamp (Â±max_deviation%).
//               Para RSI < 50: resolve pelo lado da perda (d_loss).
//               Para RSI â‰¥ 50: resolve pelo lado do ganho (d_gain).
// @param target_rsi  NÃ­vel RSI desejado (1-99)
// @param close_val   PreÃ§o de fechamento atual
// @param auc_val     EMA dos ganhos mÃ©dios (avg up change)
// @param adc_val     EMA das perdas mÃ©dias (avg down change)
// @returns           PreÃ§o que produziria o RSI-alvo, ou na se invÃ¡lido
f_rsi_calc_price(float target_rsi, float close_val, float auc_val, float adc_val) =>
    if not f_rsi_is_valid(close_val, auc_val, adc_val) or target_rsi <= 0 or target_rsi >= 100
        na
    else
        alpha = RSI_ALPHA
        denominator = 100.0 - target_rsi
        if denominator == 0
            na
        else
            target_rs = target_rsi / denominator
            float calc_price = na
            if target_rsi < 50
                new_avg_up = (1 - alpha) * auc_val
                new_avg_down = target_rs == 0 ? na : new_avg_up / target_rs
                d_loss = na(new_avg_down) ? na : (new_avg_down - (1 - alpha) * adc_val) / alpha
                calc_price := na(d_loss) ? na : close_val - d_loss
            else
                new_avg_down = (1 - alpha) * adc_val
                new_avg_up = target_rs * new_avg_down
                d_gain = (new_avg_up - (1 - alpha) * auc_val) / alpha
                calc_price := close_val + d_gain
            if na(calc_price)
                na
            else
                min_p = close_val * (1 - i_rsi_max_deviation)
                max_p = close_val * (1 + i_rsi_max_deviation)
                math.max(min_p, math.min(max_p, calc_price))

// @description  Empacota close, RSI e componentes EMA em uma tupla de 4 valores.
//               Usado como callback para request.security (uma chamada por TF).
// @returns      [close, rsi, avg_up_change, avg_down_change]
f_rsi_pack() =>
    emaLen = f_rsi_ema_length()
    [close, ta.rsi(close, i_rsi_length), ta.ema(math.max(close - close[1], 0), emaLen), ta.ema(math.max(close[1] - close, 0), emaLen)]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡Ã•ES FVG GRÃFICO
//    DetecÃ§Ã£o, renderizaÃ§Ã£o e gerenciamento de Fair Value Gaps no
//    grÃ¡fico principal. Inclui threshold adaptativo por timeframe,
//    mitigaÃ§Ã£o configurÃ¡vel (25%/50%/100%) e expiraÃ§Ã£o por idade.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @description  Calcula multiplicador de threshold baseado no timeframe.
//               InterpolaÃ§Ã£o linear entre faixas: 1sâ†’60 (0.5x), 5m (0.75x),
//               15m (1.0x), 1H (1.5x), 4H (2.2x), 1D (4.0x), >1D (8.0x).
//               Resultado clampado por i_fvg_max_multiplier.
// @param tf_sec  DuraÃ§Ã£o do timeframe em segundos
// @returns       Multiplicador float para ajustar o threshold
f_fvg_get_tf_multiplier(int tf_sec) =>
    float result = switch
        tf_sec <= 60 => 0.5
        tf_sec <= 300 => 0.5 + (tf_sec - 60) * (0.75 - 0.5) / (300 - 60)
        tf_sec <= 900 => 0.75 + (tf_sec - 300) * (1.0 - 0.75) / (900 - 300)
        tf_sec <= SEC_1H => 1.0 + (tf_sec - 900) * (1.5 - 1.0) / (SEC_1H - 900)
        tf_sec <= SEC_4H => 1.5 + (tf_sec - SEC_1H) * (2.2 - 1.5) / (SEC_4H - SEC_1H)
        tf_sec <= SEC_1D => 2.2 + (tf_sec - SEC_4H) * (4.0 - 2.2) / (SEC_1D - SEC_4H)
        => 8.0
    math.min(i_fvg_max_multiplier, result)

// @description  Calcula o nÃ­vel de preÃ§o que define mitigaÃ§Ã£o de um FVG.
// @param top      Topo do FVG
// @param bottom   Base do FVG
// @param mitType  Tipo: '100%' = toque completo, '50%' = meio, '25%' = conservador
// @param isBull   true para FVG de alta (preÃ§o cai atÃ© o gap)
// @returns        NÃ­vel de preÃ§o que, se alcanÃ§ado, mitiga o FVG
f_fvg_get_mitigation_level(float top, float bottom, string mitType, bool isBull) =>
    if mitType == '100% (Completo)'
        isBull ? bottom : top
    else if mitType == '25% (Conservador)'
        isBull ? top - (top - bottom) * 0.25 : bottom + (top - bottom) * 0.25
    else
        (top + bottom) / 2.0

// @description  Renderiza o FVG como um box no grÃ¡fico (xloc.bar_time).
//               A largura Ã© birthTime + (tf_sec * ms * extend_bars).
method draw(FVG this) =>
    if not na(this) and this.isActive
        x1 = this.birthTime
        x2 = this.birthTime + (g_tf_seconds * MS_PER_SECOND * i_fvg_extend_bars)
        boxColor = this.isBull ? i_fvg_bull_color : i_fvg_bear_color
        this.boxObj := box.new(left=x1, top=this.top, right=x2, bottom=this.bottom, xloc=xloc.bar_time, border_color=na, bgcolor=boxColor)

// @description  Remove o FVG: deleta o box e marca isActive = false.
// @param wasMitigated     Se foi removido por mitigaÃ§Ã£o (vs. expiraÃ§Ã£o)
// @param mitigationPrice  PreÃ§o onde ocorreu a mitigaÃ§Ã£o (reservado para uso futuro)
method remove(FVG this, bool wasMitigated, float mitigationPrice) =>
    if not na(this)
        if not na(this.boxObj)
            this.boxObj.delete()
            this.boxObj := na
        this.isActive := false

// @description  Verifica se o preÃ§o atual mitigou este FVG.
//               Para bull: low <= nÃ­vel de mitigaÃ§Ã£o. Para bear: high >= nÃ­vel.
// @returns      [isMitigated (bool), mitigationLevel (float)]
method checkMitigation(FVG this) =>
    bool isMitigated = false
    float mitigationLevel = f_fvg_get_mitigation_level(this.top, this.bottom, i_fvg_mitigation_type, this.isBull)
    if time > this.birthTime
        isMitigated := this.isBull ? (low <= mitigationLevel) : (high >= mitigationLevel)
    [isMitigated, mitigationLevel]

// @description  Verifica se o FVG expirou por idade (barras desde criaÃ§Ã£o > max_age).
// @returns      true se expirado
method isExpired(FVG this) =>
    if g_tf_seconds <= 0
        false
    else
        barsAge = int((time - this.birthTime) / (g_tf_seconds * MS_PER_SECOND))
        barsAge > i_fvg_max_age

// @description  Detecta FVGs (3-bar pattern) na barra atual.
//               Bull FVG: low > high[2] (gap acima). Bear FVG: high < low[2] (gap abaixo).
//               Threshold pode ser fixo (% do preÃ§o) ou automÃ¡tico (baseado em ATR).
// @returns      [isBullFvg, isBearFvg, FVG object, threshold usado, valor ATR]
f_fvg_detect() =>
    float atr_value = i_fvg_auto_threshold or i_fvg_debug ? ta.atr(i_atr_period) : na
    float threshold = na
    float bullGapSize = na
    float bearGapSize = na
    if i_fvg_auto_threshold
        float atr_safe = math.max(atr_value, syminfo.mintick)
        threshold := 1.0
        if i_fvg_adaptive_tf
            threshold := threshold * f_fvg_get_tf_multiplier(g_tf_seconds)
        bullGapSize := (low - high[2]) / atr_safe
        bearGapSize := (low[2] - high) / atr_safe
    else
        threshold := i_fvg_threshold / 100.0
        if i_fvg_adaptive_tf
            threshold := threshold * f_fvg_get_tf_multiplier(g_tf_seconds)
        bullGapSize := (low - high[2]) / math.max(high[2], syminfo.mintick)
        bearGapSize := (low[2] - high) / math.max(low[2], syminfo.mintick)
    isBullFvg = low > high[2] and bullGapSize > threshold
    isBearFvg = high < low[2] and bearGapSize > threshold
    bool hasEnoughBars = bar_index >= 2 and not na(time[2])
    FVG newFvg = isBullFvg and hasEnoughBars ? FVG.new(low, high[2], true, time[2], na, na, true) :
                 isBearFvg and hasEnoughBars ? FVG.new(low[2], high, false, time[2], na, na, true) :
                 FVG.new(na, na, false, 0, na, na, false)
    [isBullFvg, isBearFvg, newFvg, threshold, atr_value]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§± MÃ‰TODOS CANDLESET
//    MÃ©todos que operam sobre instÃ¢ncias de CandleSet.
//    Pipeline principal: Monitor() â†’ UpdateTime() â†’ Update() â†’ FindImbalance()
//    - Monitor: detecta novo candle HTF e cria objetos grÃ¡ficos
//    - UpdateTime: atualiza OHLC do candle mais recente com dados da barra atual
//    - Update/Reorder: reposiciona todos os elementos visuais no grÃ¡fico
//    - FindImbalance: detecta FVGs/VIs entre os candles HTF
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @description  Atualiza o candle HTF mais recente com OHLC da barra atual.
//               Executa a cada barra para manter o candle "vivo" atualizado.
// @param offset  PosiÃ§Ã£o horizontal atual (nÃ£o utilizado diretamente aqui)
// @returns       O prÃ³prio CandleSet (fluent interface)
method UpdateTime(CandleSet candleSet, int offset) =>
    if candleSet.candles.size() > 0
        Candle candle = candleSet.candles.get(0)
        candle.c := close
        candle.c_idx := bar_index
        if high > candle.h
            candle.h := high
            candle.h_idx := bar_index
        if low < candle.l
            candle.l := low
            candle.l_idx := bar_index
    candleSet

// @description  Reposiciona visualmente todos os candles, labels e imbalances.
//               Calcula posiÃ§Ã£o bar_index + offset para cada candle no array.
//               TambÃ©m cria/atualiza labels de nome do TF, timer e DOW.
// @param offset  PosiÃ§Ã£o horizontal inicial (bar_index + offset)
// @returns       O prÃ³prio CandleSet (fluent interface)
method Reorder(CandleSet candleSet, int offset) =>
    size = candleSet.candles.size()
    if size > 0
        for i = size - 1 to 0
            Candle candle = candleSet.candles.get(i)
            t_buffer = offset + (settings.width + settings.buffer) * (size - i - 1)
            box.set_left(candle.body, bar_index + t_buffer)
            box.set_right(candle.body, bar_index + settings.width + t_buffer)
            line.set_x1(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x1(candle.wick_down, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_down, bar_index + settings.width / 2 + t_buffer)
            if settings.daily_name
                if not na(candle.dow_label)
                    candle.dow_label.set_y(candle.h)
                    candle.dow_label.set_x(bar_index + settings.width / 2 + t_buffer)
                else
                    candle.dow_label := label.new(bar_index + settings.width / 2 + t_buffer, candle.h, candle.dow, color=color_transparent, textcolor=settings.dow_color, style=label.style_label_down, size=settings.dow_size)
    top = 0.0
    bottom = 0.0
    if settings.label_alignment == 'Align'
        top := f_candles_high()
        bottom := f_candles_low(top)
    if settings.label_alignment == 'Follow Candles'
        top := f_candle_set_high(candleSet.candles, 0)
        bottom := f_candle_set_low(candleSet.candles, top)
    left = bar_index + offset + (settings.width + settings.buffer) * (size - 1) / 2
    if settings.htf_label_show
        string lblt = f_htf_name(candleSet.settings.htf)
        string lbll = lblt
        if settings.htf_timer_show
            lblt := lblt + '\n'
            lbll := '\n' + lbll
        if settings.daily_name
            lblt := lblt + '\n'
        int currentOpenTime = 0
        if candleSet.candles.size() > 0
            currentOpenTime := candleSet.candles.get(0).o_time
        string tmr = '(' + f_remaining_time(candleSet.settings.htf, currentOpenTime) + ')' + (settings.daily_name ? '\n' : '')
        if settings.label_position == 'Both' or settings.label_position == 'Top'
            if not na(candleSet.tfNameTop)
                candleSet.tfNameTop.set_xy(left, top)
            else
                candleSet.tfNameTop := label.new(left, top, lblt, color=color_transparent, textcolor=settings.htf_label_color, style=label.style_label_down, size=settings.htf_label_size)
            if settings.htf_timer_show
                if not na(candleSet.tfTimerTop)
                    candleSet.tfTimerTop.set_xy(left, top)
                    candleSet.tfTimerTop.set_text(tmr)
                else
                    candleSet.tfTimerTop := label.new(left, top, tmr, color=color_transparent, textcolor=settings.htf_timer_color, style=label.style_label_down, size=settings.htf_timer_size)
        if settings.label_position == 'Both' or settings.label_position == 'Bottom'
            if not na(candleSet.tfNameBottom)
                candleSet.tfNameBottom.set_xy(left, bottom)
            else
                candleSet.tfNameBottom := label.new(left, bottom, lbll, color=color_transparent, textcolor=settings.htf_label_color, style=label.style_label_up, size=settings.htf_label_size)
            if settings.htf_timer_show
                if not na(candleSet.tfTimerBottom)
                    candleSet.tfTimerBottom.set_xy(left, bottom)
                    candleSet.tfTimerBottom.set_text(tmr)
                else
                    candleSet.tfTimerBottom := label.new(left, bottom, tmr, color=color_transparent, textcolor=settings.htf_timer_color, style=label.style_label_up, size=settings.htf_timer_size)
    if candleSet.imbalances.size() > 0
        for i = 0 to candleSet.imbalances.size() - 1
            Imbalance imb = candleSet.imbalances.get(i)
            t_buf2 = offset + (settings.width + settings.buffer) * (size - imb.arr_i2 - 1)
            t_buf1 = offset + (settings.width + settings.buffer) * (size - imb.arr_i1 - 1)
            box.set_left(imb.b, bar_index + t_buf2)
            box.set_right(imb.b, bar_index + t_buf1 + settings.width)
    candleSet

// @description  Atualiza visualmente o candle mais recente (body, wick, cores)
//               e opcionalmente desenha trace lines (OHLC â†’ candles HTF).
//               Chama Reorder() internamente para reposicionar tudo.
// @param offset     PosiÃ§Ã£o horizontal inicial
// @param showTrace  Se true, desenha/atualiza as trace lines OHLC
// @returns          O prÃ³prio CandleSet (fluent interface)
method Update(CandleSet candleSet, int offset, bool showTrace) =>
    candleSet.Reorder(offset)
    if candleSet.candles.size() > 0
        Candle candle = candleSet.candles.get(0)
        bull = candle.c > candle.o
        box.set_top(candle.body, math.max(candle.o, candle.c))
        box.set_bottom(candle.body, math.min(candle.o, candle.c))
        box.set_bgcolor(candle.body, bull ? settings.bull_body : settings.bear_body)
        box.set_border_color(candle.body, bull ? settings.bull_border : settings.bear_border)
        line.set_y1(candle.wick_up, candle.h)
        line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
        line.set_color(candle.wick_up, bull ? settings.bull_wick : settings.bear_wick)
        line.set_y1(candle.wick_down, math.min(candle.o, candle.c))
        line.set_y2(candle.wick_down, candle.l)
        line.set_color(candle.wick_down, bull ? settings.bull_wick : settings.bear_wick)
        if showTrace and settings.trace_show
            t_buffer = offset + (settings.width + settings.buffer) * (candleSet.candles.size() - 1)
            if not na(trace.o)
                line.set_xy1(trace.o, bar_index, candle.o), line.set_xy2(trace.o, bar_index + t_buffer, candle.o)
            else
                trace.o := line.new(bar_index, candle.o, bar_index + t_buffer, candle.o, color=settings.trace_o_color, style=f_line_style(settings.trace_o_style), width=settings.trace_o_size)
            if not na(trace.c)
                line.set_xy1(trace.c, bar_index, candle.c), line.set_xy2(trace.c, bar_index + t_buffer, candle.c)
            else
                trace.c := line.new(bar_index, candle.c, bar_index + t_buffer, candle.c, color=settings.trace_c_color, style=f_line_style(settings.trace_c_style), width=settings.trace_c_size)
            if not na(trace.h)
                line.set_xy1(trace.h, bar_index, candle.h), line.set_xy2(trace.h, bar_index + t_buffer, candle.h)
            else
                trace.h := line.new(bar_index, candle.h, bar_index + t_buffer, candle.h, color=settings.trace_h_color, style=f_line_style(settings.trace_h_style), width=settings.trace_h_size)
            if not na(trace.l)
                line.set_xy1(trace.l, bar_index, candle.l), line.set_xy2(trace.l, bar_index + t_buffer, candle.l)
            else
                trace.l := line.new(bar_index, candle.l, bar_index + t_buffer, candle.l, color=settings.trace_l_color, style=f_line_style(settings.trace_l_style), width=settings.trace_l_size)
            if settings.label_show
                if not na(trace.o_l)
                    label.set_xy(trace.o_l, bar_index + t_buffer + settings.width, candle.o)
                else
                    trace.o_l := label.new(bar_index + t_buffer + settings.width, candle.o, str.tostring(candle.o, format.mintick), color=color_transparent, textcolor=settings.label_color, style=label.style_label_left, size=settings.label_size)
                if not na(trace.c_l)
                    label.set_xy(trace.c_l, bar_index + t_buffer + settings.width, candle.c)
                else
                    trace.c_l := label.new(bar_index + t_buffer + settings.width, candle.c, str.tostring(candle.c, format.mintick), color=color_transparent, textcolor=settings.label_color, style=label.style_label_left, size=settings.label_size)
                if not na(trace.h_l)
                    label.set_xy(trace.h_l, bar_index + t_buffer + settings.width, candle.h)
                else
                    trace.h_l := label.new(bar_index + t_buffer + settings.width, candle.h, str.tostring(candle.h, format.mintick), color=color_transparent, textcolor=settings.label_color, style=label.style_label_left, size=settings.label_size)
                if not na(trace.l_l)
                    label.set_xy(trace.l_l, bar_index + t_buffer + settings.width, candle.l)
                else
                    trace.l_l := label.new(bar_index + t_buffer + settings.width, candle.l, str.tostring(candle.l, format.mintick), color=color_transparent, textcolor=settings.label_color, style=label.style_label_left, size=settings.label_size)
    candleSet

// @description  Detecta FVGs e Volume Imbalances entre os candles HTF do set.
//               SÃ³ executa na Ãºltima barra (isrealtime/islast) para performance.
//               FVG: 3-bar pattern (candle i vs candle i+2).
//               VI: 2-bar pattern (candle i vs candle i+1).
//               A cada novo candle, limpa imbalances antigos e recalcula tudo.
// @returns      O prÃ³prio CandleSet (fluent interface)
method FindImbalance(CandleSet candleSet) =>
    int candleCount = candleSet.candles.size()
    if candleCount >= 3 and (barstate.isrealtime or barstate.islast)
        Candle lastCandle = candleSet.candles.get(candleCount - 1)
        int currentCandleIdx = lastCandle.o_idx
        int lastProcessedIdx = candleSet.imbalances.size() > 0 ? candleSet.imbalances.get(candleSet.imbalances.size() - 1).idx : -1
        bool isNewCandle = currentCandleIdx > lastProcessedIdx or lastProcessedIdx == -1
        if isNewCandle
            if candleSet.imbalances.size() > 0
                for i = candleSet.imbalances.size() - 1 to 0
                    Imbalance del = candleSet.imbalances.get(i)
                    box.delete(del.b)
                    candleSet.imbalances.pop()
            if candleCount >= 3 and settings.fvg_show
                for i = 0 to candleCount - 3 by 1
                    candle1 = candleSet.candles.get(i)
                    candle2 = candleSet.candles.get(i + 2)
                    if candle1.l > candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_left(candle2.body), candle2.h, box.get_right(candle1.body), candle1.l, bgcolor=settings.fvg_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 2
                        candleSet.imbalances.push(imb)
                    if candle1.h < candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_right(candle1.body), candle1.h, box.get_left(candle2.body), candle2.l, bgcolor=settings.fvg_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 2
                        candleSet.imbalances.push(imb)
            if candleCount > 2 and settings.vi_show
                for i = 0 to candleCount - 2 by 1
                    candle1 = candleSet.candles.get(i)
                    candle2 = candleSet.candles.get(i + 1)
                    if candle1.l < candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_left(candle2.body), math.min(candle1.o, candle1.c), box.get_right(candle1.body), math.max(candle2.o, candle2.c), bgcolor=settings.vi_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 1
                        candleSet.imbalances.push(imb)
                    if candle1.h > candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                        Imbalance imb = Imbalance.new()
                        imb.b := box.new(box.get_right(candle1.body), math.min(candle2.o, candle2.c), box.get_left(candle2.body), math.max(candle1.o, candle1.c), bgcolor=settings.vi_color, border_color=color_transparent)
                        imb.idx := currentCandleIdx
                        imb.arr_i1 := i
                        imb.arr_i2 := i + 1
                        candleSet.imbalances.push(imb)
    candleSet

// @description  Detecta inÃ­cio de novo candle HTF e cria objetos grÃ¡ficos.
//               Usa time(htf) + ta.change para detectar abertura de novo perÃ­odo.
//               Anti-repaint: sÃ³ cria em barstate.isconfirmed || ishistory.
//               Remove o candle mais antigo se exceder max_display (FIFO).
// @returns      O prÃ³prio CandleSet (fluent interface)
// [FIX v1.2.0] Monitor usa timeframe.in_seconds
method Monitor(CandleSet candleSet) =>
    // [FIX v1.2.0] Usa forma nativa simples para alinhar com o mercado
    HTFBarTime = time(candleSet.settings.htf)
    isNewHTFCandle = ta.change(HTFBarTime) > 0
    // Anti-repaint: cria em barra confirmada, com fallback para carga histÃ³rica
    if isNewHTFCandle and (barstate.isconfirmed or barstate.ishistory)
        Candle candle = Candle.new()
        candle.o := open, candle.c := close, candle.h := high, candle.l := low
        candle.o_time := time, candle.o_idx := bar_index, candle.c_idx := bar_index
        candle.h_idx := bar_index, candle.l_idx := bar_index
        // [FIX v1.2.0] Usa timeframe.in_seconds() em vez de str.tonumber()
        int htfSec = timeframe.in_seconds(candleSet.settings.htf)
        candle.dow := switch
            candleSet.settings.htf == '1W' => 'Sem ' + str.tostring(weekofyear(time, i_timezone))
            candleSet.settings.htf == '1D' => f_day_of_week(dayofweek(time_tradingday))
            htfSec < SEC_1H => str.format_time(candle.o_time, 'm', i_timezone)
            htfSec >= SEC_1H and htfSec < SEC_1D => str.format_time(candle.o_time, 'H', i_timezone)
            => ''
        bull = candle.c > candle.o
        candle.body := box.new(bar_index, math.max(candle.o, candle.c), bar_index + 2, math.min(candle.o, candle.c), bull ? settings.bull_border : settings.bear_border, 1, bgcolor=bull ? settings.bull_body : settings.bear_body)
        candle.wick_up := line.new(bar_index + 1, candle.h, bar_index, math.max(candle.o, candle.c), color=bull ? settings.bull_wick : settings.bear_wick)
        candle.wick_down := line.new(bar_index + 1, math.min(candle.o, candle.c), bar_index, candle.l, color=bull ? settings.bull_wick : settings.bear_wick)
        candleSet.candles.unshift(candle)
        if candleSet.candles.size() > candleSet.settings.max_display
            Candle delCandle = array.pop(candleSet.candles)
            box.delete(delCandle.body)
            line.delete(delCandle.wick_up)
            line.delete(delCandle.wick_down)
            if not na(delCandle.dow_label)
                delCandle.dow_label.delete()
    candleSet

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š CÃLCULOS & REQUEST.SECURITY
//    Executa cÃ¡lculos globais (EMA, RSI, componentes RSI) e busca dados
//    de mÃºltiplos timeframes via request.security (5 chamadas RSI + 1 FVG).
//    Resultados sÃ£o armazenados nos arrays globais g_rsi_*.
//    [FIX v1.2.0] request.security desenrolado â€” Pine v6 proÃ­be dentro de loops.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// --- CÃ¡lculos locais do TF atual ---
ema_value = ta.ema(i_emaSource, i_emaLength)            // EMA para plot no grÃ¡fico
rsiEmaLength = f_rsi_ema_length()                        // Comprimento EMA p/ componentes RSI
rsi_current = ta.rsi(close, i_rsi_length)                // RSI do TF atual (usado nos alertas)
auc_current = ta.ema(math.max(close - close[1], 0), rsiEmaLength)  // Avg up change (TF atual)
adc_current = ta.ema(math.max(close[1] - close, 0), rsiEmaLength)  // Avg down change (TF atual)


// --- Busca dados RSI de 5 timeframes via request.security ---
// Cada chamada retorna [close, rsi, avg_up, avg_down] do TF correspondente.
// lookahead=off e gaps=off para evitar repaint e preencher barras sem dados.
// [FIX v1.2.0] request.security desenrolado â€” Pine v6 proÃ­be dentro de loops
[c1, r1, au1, ad1] = request.security(syminfo.tickerid, i_rsi_tf1, f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
[c2, r2, au2, ad2] = request.security(syminfo.tickerid, i_rsi_tf2, f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
[c3, r3, au3, ad3] = request.security(syminfo.tickerid, i_rsi_tf3, f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
[c4, r4, au4, ad4] = request.security(syminfo.tickerid, i_rsi_tf4, f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
[c5, r5, au5, ad5] = request.security(syminfo.tickerid, i_rsi_tf5, f_rsi_pack(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)


// Armazena resultados nos arrays globais (1 Ã­ndice por TF)
g_rsi_close.set(0, c1), g_rsi_values.set(0, r1), g_rsi_auc.set(0, au1), g_rsi_adc.set(0, ad1)
g_rsi_close.set(1, c2), g_rsi_values.set(1, r2), g_rsi_auc.set(1, au2), g_rsi_adc.set(1, ad2)
g_rsi_close.set(2, c3), g_rsi_values.set(2, r3), g_rsi_auc.set(2, au3), g_rsi_adc.set(2, ad3)
g_rsi_close.set(3, c4), g_rsi_values.set(3, r4), g_rsi_auc.set(3, au4), g_rsi_adc.set(3, ad4)
g_rsi_close.set(4, c5), g_rsi_values.set(4, r5), g_rsi_auc.set(4, au5), g_rsi_adc.set(4, ad5)

// --- DetecÃ§Ã£o de FVG no timeframe configurado (ou TF atual se vazio) ---
tfFinal = i_fvg_timeframe == '' ? timeframe.period : i_fvg_timeframe
g_tf_seconds := timeframe.in_seconds(tfFinal)
[isBull, isBear, detectedFvg, thresholdUsed, atrValue] = request.security(syminfo.tickerid, tfFinal, f_fvg_detect(), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš¡ LÃ“GICA PRINCIPAL - FVG GRÃFICO
//    Ciclo de vida dos FVGs no grÃ¡fico principal:
//    1. Snapshot: salva g_last_fvg_time para detecÃ§Ã£o de duplicatas
//    2. CriaÃ§Ã£o: novo FVG detectado â†’ draw() e push no array ativo
//    3. MitigaÃ§Ã£o/ExpiraÃ§Ã£o: verifica cada FVG ativo e remove se necessÃ¡rio
//    4. Garbage collection: limpa tudo se feature desligada
//    Tudo protegido por barstate.isconfirmed (anti-repaint).
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Passo 1: Snapshot do timestamp antes de processar novo FVG
if barstate.isconfirmed
    g_prev_fvg_time := g_last_fvg_time

// Passo 2: Se detectou FVG novo (birthTime > Ãºltimo registrado), adiciona
if i_fvg_enabled and barstate.isconfirmed and (isBull or isBear) and detectedFvg.birthTime > g_last_fvg_time
    if g_active_fvgs.size() < i_fvg_max_count and detectedFvg.isActive
        g_last_fvg_time := detectedFvg.birthTime
        detectedFvg.draw()
        g_active_fvgs.unshift(detectedFvg)

// Passo 3: MitigaÃ§Ã£o e ExpiraÃ§Ã£o dos FVGs ativos
// Itera sobre os FVGs ativos (limitado por MAX_ITER_PER_BAR para performance).
// FVGs mitigados ou expirados sÃ£o marcados para remoÃ§Ã£o em batch.
// [FIX v1.2.0] Anti-repaint: mitigaÃ§Ã£o/expiraÃ§Ã£o APENAS em barstate.isconfirmed
if i_fvg_enabled and barstate.isconfirmed and g_active_fvgs.size() > 0
    if g_fvg_to_remove.size() > 0
        g_fvg_to_remove.clear()
    int arraySize = g_active_fvgs.size()
    int maxIter = math.min(arraySize, MAX_ITER_PER_BAR)
    for i = 0 to maxIter - 1
        if g_fvg_to_remove.size() >= MAX_REMOVALS
            break
        fvg = g_active_fvgs.get(i)
        if fvg.isActive
            [wasMitigated, mitigationPrice] = fvg.checkMitigation()
            wasExpired = fvg.isExpired()
            if wasMitigated or wasExpired
                fvg.remove(wasMitigated, mitigationPrice)
                g_fvg_to_remove.push(i)
    if g_fvg_to_remove.size() > 0
        g_fvg_to_remove.sort(order.descending)
        for i = 0 to g_fvg_to_remove.size() - 1
            g_active_fvgs.remove(g_fvg_to_remove.get(i))


// Passo 4: Garbage collection quando FVG Feature desligada
// [FIX v1.2.0] Garbage collection: limpa FVGs quando feature desligada
if not i_fvg_enabled and g_active_fvgs.size() > 0
    for i = 0 to g_active_fvgs.size() - 1
        fvg = g_active_fvgs.get(i)
        if fvg.isActive
            fvg.remove(false, na) // Remove o FVG sem considerar mitigaÃ§Ã£o/expiraÃ§Ã£o
    g_active_fvgs.clear() // Limpa o array de FVGs ativos
    g_last_fvg_time := 0   // Reseta o timestamp do Ãºltimo FVG
    g_prev_fvg_time := 0   // Reseta o timestamp do FVG anterior

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“‹ CACHE RSI - PREÃ‡OS-ALVO
//    Calcula preÃ§os que levariam o RSI a nÃ­veis especÃ­ficos (25/30/50/70/75/custom).
//    Cache sÃ³ Ã© recalculado quando: barra nova OU Ãºltima barra mudou de Ã­ndice.
//    Evita recalcular a cada tick (performance).
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool use_rsi_25 = i_show_rsi_25
bool use_rsi_30 = i_show_rsi_30
bool use_rsi_50 = i_show_rsi_50
bool use_rsi_70 = i_show_rsi_70
bool use_rsi_75 = i_show_rsi_75
bool use_rsi_custom = i_show_rsi_custom

// CondiÃ§Ã£o de recalc: barra nova OU Ãºltima barra com bar_index diferente
bool should_calculate = barstate.isnew or (barstate.islast and g_last_calc_bar != bar_index)
if should_calculate
    g_cached_rsi25 := use_rsi_25 ? f_rsi_calc_price(25.0, close, auc_current, adc_current) : na
    g_cached_rsi30 := use_rsi_30 ? f_rsi_calc_price(30.0, close, auc_current, adc_current) : na
    g_cached_rsi50 := use_rsi_50 ? f_rsi_calc_price(50.0, close, auc_current, adc_current) : na
    g_cached_rsi70 := use_rsi_70 ? f_rsi_calc_price(70.0, close, auc_current, adc_current) : na
    g_cached_rsi75 := use_rsi_75 ? f_rsi_calc_price(75.0, close, auc_current, adc_current) : na
    g_cached_rsi_custom := i_show_rsi_custom ? f_rsi_calc_price(i_rsi_custom_level, close, auc_current, adc_current) : na
    g_last_calc_bar := bar_index

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ RENDERIZAÃ‡ÃƒO VISUAL
//    Plots no grÃ¡fico principal: EMA e linhas RSI (preÃ§os-alvo cacheados).
//    SÃ£o plots de nÃ­vel superior (top scope) obrigatÃ³rios em Pine Script.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// --- EMA ---
plot(i_showEMA ? ema_value : na, title='EMA', color=i_emaColor, linewidth=i_emaWidth)

// --- RSI Lines: plotam preÃ§os-alvo para cada nÃ­vel RSI ativo ---
plot(i_show_rsi_25 ? g_cached_rsi25 : na, 'RSI 25', color.new(#00bcd4, 0), 1, plot.style_line)
plot(i_show_rsi_30 ? g_cached_rsi30 : na, 'RSI 30', color.new(color.red, 0), 1, plot.style_line)
plot(i_show_rsi_50 ? g_cached_rsi50 : na, 'RSI 50', color.new(color.gray, 0), 1, plot.style_line)
plot(i_show_rsi_70 ? g_cached_rsi70 : na, 'RSI 70', color.new(color.green, 0), 1, plot.style_line)
plot(i_show_rsi_75 ? g_cached_rsi75 : na, 'RSI 75', color.new(#ff5722, 0), 1, plot.style_line)
plot(i_show_rsi_custom ? g_cached_rsi_custom : na, 'RSI Custom', i_rsi_custom_color, 2, plot.style_line)

// --- TABELA RSI MTF ---
// Tabela interativa com RSI de 5 TFs + colunas opcionais de preÃ§o-alvo.
// A tabela Ã© recriada quando a configuraÃ§Ã£o de colunas muda.
// Cores das cÃ©lulas: escala de f_rsi_color() (verde=oversold, vermelho=overbought).
bool show_col1 = i_table_show_col1     // Coluna de preÃ§o-alvo para nÃ­vel col1
bool show_col2 = i_table_show_col2     // Coluna de preÃ§o-alvo para nÃ­vel col2
int total_cols = 2                     // TF + RSI (base) + colunas opcionais
int col_p1 = na
if show_col1
    col_p1 := total_cols
    total_cols += 1
int col_p2 = na
if show_col2
    col_p2 := total_cols
    total_cols += 1

pos_rsi = switch i_table_position
    'top_right' => position.top_right
    'top_left' => position.top_left
    'bottom_right' => position.bottom_right
    => position.bottom_left

if i_table_show and barstate.islast
    int current_col_config = (show_col1 ? 1 : 0) + (show_col2 ? 2 : 0)
    if current_col_config != g_prev_col_config and not na(g_rsi_table)
        table.delete(g_rsi_table)
        g_rsi_table := na
    g_prev_col_config := current_col_config
    if na(g_rsi_table)
        g_rsi_table := table.new(pos_rsi, total_cols, MAX_TABLE_ROWS, bgcolor=color.new(#282a36, 0), border_width=0, frame_width=2, frame_color=color.new(#6272a4, 0))
        table.cell(g_rsi_table, 0, 0, '  TF  ', text_color=color.new(#bd93f9, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
        table.cell(g_rsi_table, 1, 0, '    RSI     ', text_color=color.new(#bd93f9, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
        if show_col1
            table.cell(g_rsi_table, col_p1, 0, '        ' + str.tostring(i_table_col1_level, '#') + '        ', text_color=color.new(#bd93f9, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
        if show_col2
            table.cell(g_rsi_table, col_p2, 0, '        ' + str.tostring(i_table_col2_level, '#') + '        ', text_color=color.new(#bd93f9, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
    for i = 0 to 4
        rsi_val = g_rsi_values.get(i)
        [bg, txt_clr] = f_rsi_color(rsi_val)
        table.cell(g_rsi_table, 0, i+1, g_rsi_tfs_display.get(i), bgcolor=bg, text_color=txt_clr, text_size=size.small)
        table.cell(g_rsi_table, 1, i+1, na(rsi_val) ? "â€”" : str.tostring(rsi_val, "#.##"), bgcolor=bg, text_color=txt_clr, text_size=size.normal)
        if show_col1
            p1 = f_rsi_calc_price(i_table_col1_level, g_rsi_close.get(i), g_rsi_auc.get(i), g_rsi_adc.get(i))
            bg1 = (not na(rsi_val) and rsi_val <= i_table_col1_level) ? color.new(#3de1c7, 20) : color.new(#282a36, 0)
            txt1 = (not na(rsi_val) and rsi_val <= i_table_col1_level) ? color.new(#282a36, 0) : color.new(#f8f8f2, 0)
            table.cell(g_rsi_table, col_p1, i+1, na(p1) ? "â€”" : str.tostring(p1, format.mintick), bgcolor=bg1, text_color=txt1, text_size=size.normal)
        if show_col2
            p2 = f_rsi_calc_price(i_table_col2_level, g_rsi_close.get(i), g_rsi_auc.get(i), g_rsi_adc.get(i))
            bg2 = (not na(rsi_val) and rsi_val >= i_table_col2_level) ? color.new(#ff4d8d, 20) : color.new(#282a36, 0)
            txt2 = (not na(rsi_val) and rsi_val >= i_table_col2_level) ? color.new(#282a36, 0) : color.new(#f8f8f2, 0)
            table.cell(g_rsi_table, col_p2, i+1, na(p2) ? "â€”" : str.tostring(p2, format.mintick), bgcolor=bg2, text_color=txt2, text_size=size.normal)

// [FIX v1.2.0] Garbage collection: limpa tabela RSI quando feature desligada
if not i_table_show and not na(g_rsi_table)
    table.delete(g_rsi_table)
    g_rsi_table := na
    g_prev_col_config := 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š LÃ“GICA ICT - HTF CANDLES
//    Pipeline principal de cada slot HTF:
//    1. UpdateTime: atualiza OHLC do candle vivo com dados da barra atual
//    2. Monitor:    detecta novo candle HTF e cria objetos grÃ¡ficos
//    3. Update:     reposiciona e redesenha tudo (+ trace lines se aplicÃ¡vel)
//    4. FindImbalance: detecta FVGs/VIs entre os candles do slot
//    Offset Ã© acumulado entre slots para posicionar lado a lado.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
int cnt = 0            // Contador de slots jÃ¡ renderizados
int last = f_htf_enabled()   // Total de slots habilitados (max = settings.max_sets)
int offset = settings.offset // PosiÃ§Ã£o horizontal inicial (Ã  direita do grÃ¡fico)

// --- Slot HTF 1 ---
if htf1.settings.show and f_valid_timeframe(htf1.settings.htf)
    bool showTrace = (settings.trace_anchor == 'First Timeframe') or (settings.trace_anchor == 'Last Timeframe' and settings.max_sets == 1)
    htf1.UpdateTime(offset)
    htf1.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf1.candles.size() * settings.width + (htf1.candles.size() > 0 ? (htf1.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

// --- Slot HTF 2 ---
if htf2.settings.show and f_valid_timeframe(htf2.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf2.UpdateTime(offset)
    htf2.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf2.candles.size() * settings.width + (htf2.candles.size() > 0 ? (htf2.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

// --- Slot HTF 3 ---
if htf3.settings.show and f_valid_timeframe(htf3.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf3.UpdateTime(offset)
    htf3.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf3.candles.size() * settings.width + (htf3.candles.size() > 0 ? (htf3.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

// --- Slot HTF 4 ---
if htf4.settings.show and f_valid_timeframe(htf4.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf4.UpdateTime(offset)
    htf4.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf4.candles.size() * settings.width + (htf4.candles.size() > 0 ? (htf4.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

// --- Slot HTF 5 ---
if htf5.settings.show and f_valid_timeframe(htf5.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe' and cnt == last - 1)
    htf5.UpdateTime(offset)
    htf5.Monitor().Update(offset, showTrace).FindImbalance()
    cnt += 1
    offset += htf5.candles.size() * settings.width + (htf5.candles.size() > 0 ? (htf5.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer

// --- Slot HTF 6 ---
if htf6.settings.show and f_valid_timeframe(htf6.settings.htf) and cnt < last
    bool showTrace = (settings.trace_anchor == 'First Timeframe' and cnt == 0) or (settings.trace_anchor == 'Last Timeframe')
    htf6.UpdateTime(offset)
    htf6.Monitor().Update(offset, showTrace).FindImbalance()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” DEBUG MODE
//    Tabela de diagnÃ³stico exibida no canto inferior esquerdo.
//    Mostra: FVGs ativos, modo de threshold, ATR, mitigaÃ§Ã£o, TF seconds,
//    e detalhes do Ãºltimo FVG. Ãštil para desenvolvimento e troubleshooting.
//    Garbage collection: tabela deletada quando debug Ã© desligado.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// [FIX v1.2.0] Protegido contra NaN â€” usa nz() e na() checks

if i_fvg_debug
    if na(g_debug_table)
        g_debug_table := table.new(position.bottom_left, 2, 8, bgcolor=color.new(#282a36, 0), border_width=2, border_color=color.new(#bd93f9, 0))
        table.cell(g_debug_table, 0, 0, 'ğŸ” FVG Debug V1.2.0', text_color=color.new(#f8f8f2, 0), bgcolor=color.new(#6272a4, 0))
        table.merge_cells(g_debug_table, 0, 0, 1, 0)
    if barstate.islast
        activeCount = g_active_fvgs.size()
        table.cell(g_debug_table, 0, 1, 'FVGs Ativos:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 1, str.tostring(activeCount)+'/'+str.tostring(i_fvg_max_count), text_color=activeCount>12?color.new(#ffb86c, 0):color.new(#50fa7b, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 2, 'Modo:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 2, i_fvg_auto_threshold?'ğŸ“Š ATR':(i_fvg_adaptive_tf?'âš™ï¸ Adaptativo':'ğŸ“ Fixo'), text_color=color.new(#f8f8f2, 0), bgcolor=color.new(#44475a, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 3, 'Threshold:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 3, na(thresholdUsed) ? 'â€”' : str.tostring(nz(thresholdUsed, 0)*100,'#.###')+'%', text_color=color.new(#f8f8f2, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 4, 'ATR('+str.tostring(i_atr_period)+'):', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 4, na(atrValue) ? 'â€”' : str.tostring(atrValue, format.mintick), text_color=color.new(#8be9fd, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 5, 'MitigaÃ§Ã£o:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 5, i_fvg_mitigation_type, text_color=color.new(#50fa7b, 0), text_size=size.tiny)
        table.cell(g_debug_table, 0, 6, 'TF Seconds:', text_color=color.new(#6272a4, 0), text_size=size.small)
        table.cell(g_debug_table, 1, 6, str.tostring(g_tf_seconds), text_color=color.new(#f8f8f2, 0), text_size=size.small)
        table.cell(g_debug_table, 0, 7, 'Ãšltimo FVG:', text_color=color.new(#6272a4, 0), text_size=size.small)
        if activeCount > 0
            lastFvg = g_active_fvgs.get(0)
            fvgSize = math.abs(lastFvg.top - lastFvg.bottom)
            fvgPct = (fvgSize / math.max(lastFvg.bottom, syminfo.mintick)) * 100
            table.cell(g_debug_table, 1, 7, (lastFvg.isBull?'ğŸŸ¢ Bull':'ğŸ”´ Bear')+' ('+str.tostring(fvgPct,'#.##')+'%)', text_color=lastFvg.isBull?color.new(#50fa7b, 0):color.new(#ff5555, 0), text_size=size.tiny)
        else
            table.cell(g_debug_table, 1, 7, 'Nenhum', text_color=color.new(#6272a4, 0), text_size=size.small)
else if not i_fvg_debug and not na(g_debug_table)
    g_debug_table.delete()
    g_debug_table := na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”” ALERTAS
//    CondiÃ§Ãµes de alerta para integraÃ§Ã£o com TradingView alerts.
//    - Novo FVG Bull/Bear: usa g_prev_fvg_time (snapshot) para detectar
//      que um FVG foi adicionado nesta barra (anti-duplicata).
//    - RSI Cross 70/30: cruzamento clÃ¡ssico de sobrecompra/sobrevenda.
//    Todos protegidos por barstate.isconfirmed (anti-repaint).
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// VariÃ¡veis auxiliares de alerta (necessÃ¡rio fora do bloco if)
// g_prev_fvg_time: snapshot do g_last_fvg_time ANTES de adicionar novo FVG
// g_last_fvg_time: atualizado APÃ“S adicionar novo FVG
// NecessÃ¡rio para que alertcondition detecte o FVG recÃ©m-adicionado
bool fvg_can_be_added = g_active_fvgs.size() < i_fvg_max_count
bool fvg_is_new = detectedFvg.birthTime > nz(g_prev_fvg_time, 0)
bool new_bull_fvg = i_fvg_enabled and barstate.isconfirmed and isBull and fvg_is_new and fvg_can_be_added and detectedFvg.isActive
bool new_bear_fvg = i_fvg_enabled and barstate.isconfirmed and isBear and fvg_is_new and fvg_can_be_added and detectedFvg.isActive

// --- Alertconditions (configurÃ¡veis no painel de alertas do TradingView) ---
alertcondition(new_bull_fvg, title="Novo FVG de Alta", message="ğŸŸ¢ Novo FVG de Alta Detectado!")
alertcondition(new_bear_fvg, title="Novo FVG de Baixa", message="ğŸ”´ Novo FVG de Baixa Detectado!")
alertcondition(ta.crossover(rsi_current, 70.0), title="RSI Sobrecomprado (>70)", message="âš ï¸ RSI Cruzou 70 para cima")
alertcondition(ta.crossunder(rsi_current, 30.0), title="RSI Sobrevendido (<30)", message="âš ï¸ RSI Cruzou 30 para baixo")
